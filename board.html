<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Character encoding for proper text display -->
  <meta charset="UTF-8">
  <!-- Viewport meta tag for responsive design on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Page title displayed in browser tab -->
  <title>Office Board</title>
  
  <!-- External CSS file for styling -->
  <link rel="stylesheet" href="style.css">
  <!-- Google Fonts - Inter font family for modern typography -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Configuration file containing API endpoints and settings -->
  <script src="config.js" defer></script>
  
  <!-- Initialization script that runs when DOM is loaded -->
  <script defer>
    document.addEventListener("DOMContentLoaded", () => {
      // Create a base element to handle relative URLs for different environments
      // This allows the app to work both locally and when deployed
      const base = document.createElement('base');
      base.href = location.hostname === 'localhost' ? '/' : 'https://joshthinh.github.io/Elen-Signin/';
      document.head.appendChild(base);
  
      // Validate that required configuration variables are loaded
      // These variables define the API endpoints for local vs deployed environments
      if (typeof API_URL === 'undefined' || typeof API_URL_DEPLOYED === 'undefined') {
        console.error('API_URL or API_URL_DEPLOYED is not defined. Check config.js loading.');
        return;
      }
  
      // Set the global API URL based on current environment
      // Uses local API for development, deployed API for production
      window.ApiUrlLink = location.hostname === 'localhost' ? API_URL : API_URL_DEPLOYED;
  
      // Continue rest of logic here if needed
    });
  </script>
  <style>
    /* ===== RESPONSIVE DESIGN SYSTEM ===== */
    /* CSS Custom Properties (variables) for responsive scaling across different screen sizes */
    /* These variables control how elements scale on different devices */
    :root {
      --scale-phone: 0.8;      /* Scale down for small mobile devices */
      --scale-tablet: 0.9;     /* Slightly smaller for tablets */
      --scale-desktop: 1;      /* Full size for desktop computers */
      --scale-tv: 1.2;         /* Larger scale for TV displays */
    }
    
    /* ===== GLOBAL RESET ===== */
    /* Apply border-box sizing to all elements for consistent layout calculations */
    * {
      box-sizing: border-box;
    }
    
    /* ===== BODY STYLING ===== */
    /* Main page container with dark theme and sidebar accommodation */
    body {
      overflow-x: hidden !important;                    /* Prevent horizontal scrolling */
      max-width: 100vw !important;                      /* Limit width to viewport */
      width: 100vw !important;                          /* Full viewport width */
      margin: 0 !important;                             /* Remove default margins */
      padding: 0 !important;                            /* Remove default padding */
      padding-left: 100px !important;                   /* Space for left sidebar */
      background: #2d2e4bf2;                            /* Dark blue background with transparency */
      min-height: 100vh;                                /* Full viewport height */
      font-size: 16px;                                  /* Base font size */
      color: white;                                      /* White text for dark theme */
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    /* ===== LEFT SIDEBAR NAVIGATION ===== */
    /* Collapsible sidebar that provides navigation to different sections of the app */
    .left-sidebar {
      position: fixed;                                    /* Fixed position so it stays visible when scrolling */
      top: 0;                                            /* Align to top of viewport */
      left: 0;                                           /* Align to left edge of viewport */
      width: 100px;                                      /* Default collapsed width */
      height: 100vh;                                     /* Full viewport height */
      background: #4a4c6b;                               /* Dark blue-gray background */
      color: #fff;                                       /* White text */
      z-index: 1001;                                     /* High z-index to appear above other content */
      transition: width 0.3s ease;                       /* Smooth width transition animation */
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);       /* Subtle shadow for depth */
    }
    
    /* Expanded state of sidebar - shows full text labels */
    .left-sidebar.expanded {
      width: 200px;                                      /* Wider when expanded to show text */
    }
    
    /* Header section of sidebar with toggle button */
    .sidebar-header {
      display: flex;                                     /* Flexbox layout for centering */
      align-items: center;                               /* Vertical centering */
      justify-content: center;                           /* Horizontal centering */
      padding: 50px 15px;                               /* Padding for spacing */
      cursor: pointer;                                   /* Indicates clickable area */
      height: 50px;                                      /* Fixed height for consistency */
    }
    
    /* "Menu" text that appears when sidebar is expanded */
    .sidebar-header h3 {
      margin: 0;                                         /* Remove default margins */
      font-size: 1.1rem;                                /* Appropriate font size */
      font-weight: 600;                                  /* Medium-bold weight */
      opacity: 0;                                        /* Hidden by default (collapsed state) */
      transition: opacity 0.3s ease;                     /* Smooth fade in/out */
      position: absolute;                                /* Absolute positioning for overlay */
      left: 20px;                                       /* Left offset from edge */
    }
    
    /* Show the "Menu" text when sidebar is expanded */
    .left-sidebar.expanded .sidebar-header h3 {
      opacity: 1;                                        /* Fully visible when expanded */
    }
    
    /* Hamburger menu button (‚ò∞) for toggling sidebar */
    .sidebar-toggle {
      font-size: 2.5rem;                                 /* Large size for easy clicking */
      cursor: pointer !important;                        /* Pointer cursor to indicate clickable */
      user-select: none;                                 /* Prevent text selection */
      -webkit-user-select: none;                         /* Webkit browser support */
      -moz-user-select: none;                            /* Firefox support */
      -ms-user-select: none;                             /* IE/Edge support */
      transition: transform 0.3s ease;                    /* Smooth rotation animation */
      width: 80px;                                        /* Button width */
      height: 80px;                                       /* Button height */
      display: flex;                                      /* Flexbox for centering content */
      align-items: center;                                /* Vertical centering */
      justify-content: center;                            /* Horizontal centering */
      pointer-events: auto;                               /* Ensure button is clickable */
      background: transparent;                            /* No background */
      border: none;                                       /* No border */
      outline: none;                                      /* No outline */
      margin: 0 auto;                                     /* Center horizontally */
      position: relative;                                 /* Relative positioning */
      top: 5px;                                          /* Slight top offset */
    }
    
    /* Adjust toggle button height when sidebar is expanded */
    .left-sidebar.expanded .sidebar-toggle {
      height: 60px;                                       /* Smaller height for expanded state */
    }
    
    /* Rotate toggle button when sidebar is expanded */
    .left-sidebar.expanded .sidebar-toggle {
      transform: rotate(90deg);                           /* 90-degree rotation for visual feedback */
    }
    
    /* Close button (‚úï) that appears when sidebar is expanded */
    .sidebar-close {
      position: absolute;                                 /* Absolute positioning */
      top: 15px;                                         /* Top offset from sidebar edge */
      right: 15px;                                       /* Right offset from sidebar edge */
      font-size: 1.5rem;                                 /* Appropriate size for close button */
      cursor: pointer;                                    /* Pointer cursor */
      color: #fff;                                        /* White color */
      opacity: 0;                                         /* Hidden by default */
      transition: opacity 0.3s ease;                      /* Smooth fade in/out */
      z-index: 10;                                        /* Above other sidebar elements */
      background: none;                                   /* No background */
      border: none;                                       /* No border */
      padding: 5px;                                       /* Padding for clickable area */
      border-radius: 4px;                                 /* Rounded corners */
    }
    
    /* Show close button when sidebar is expanded */
    .left-sidebar.expanded .sidebar-close {
      opacity: 1;                                         /* Fully visible */
    }
    
    /* Hover effect for close button */
    .sidebar-close:hover {
      background: rgba(255, 255, 255, 0.1);              /* Subtle white background on hover */
    }
    
    /* Hide toggle button when sidebar is expanded to avoid confusion */
    .left-sidebar.expanded .sidebar-toggle {
      display: none;                                      /* Completely hidden */
    }
    
    /* Container for sidebar navigation icons */
    .sidebar-icons {
      padding: 10px 0;                                    /* Vertical padding for spacing */
    }
    
    /* Individual sidebar navigation item */
    .sidebar-icon-item {
      display: flex;                                      /* Flexbox layout */
      align-items: center;                                /* Vertical centering */
      justify-content: center;                            /* Horizontal centering */
      width: 100%;                                        /* Full width of sidebar */
      height: 50px;                                       /* Fixed height for consistency */
      color: #fff;                                        /* White text/icons */
      text-decoration: none;                              /* No underline */
      transition: all 0.3s ease;                          /* Smooth transitions for all properties */
      border-left: 3px solid transparent;                 /* Transparent left border for hover effect */
    }
    
    /* Hover effect for sidebar items */
    .sidebar-icon-item:hover {
      background: rgba(255, 255, 255, 0.1);              /* Subtle white background */
      border-left-color: #fff;                            /* White left border indicator */
    }
    
    /* Icon styling within sidebar items */
    .sidebar-icon-item .icon {
      font-size: 1.3rem;                                  /* Appropriate size for emoji icons */
      filter: grayscale(60%);                              /* Slightly desaturated for subtle appearance */
    }
    
    /* Container for text-based navigation (shown when sidebar is expanded) */
    .sidebar-text {
      padding: 20px 0;                                    /* Vertical padding for spacing */
    }
    
    /* Individual text navigation links */
    .sidebar-text a {
      display: block;                                      /* Block display for full-width clickable area */
      padding: 15px 20px;                                 /* Comfortable padding for clicking */
      color: #fff;                                         /* White text */
      text-decoration: none;                              /* No underline */
      font-size: 0.95rem;                                 /* Slightly smaller than body text */
      transition: all 0.3s ease;                          /* Smooth transitions */
      border-left: 3px solid transparent;                 /* Transparent left border for hover effect */
    }
    
    /* Hover effect for text navigation links */
    .sidebar-text a:hover {
      background: rgba(255, 255, 255, 0.1);              /* Subtle white background */
      border-left-color: #fff;                            /* White left border indicator */
    }
    
    /* ===== MAIN BOARD CONTENT AREA ===== */
    /* Main container for the office board visualization */
    .board-container {
      flex: 1;                                             /* Take remaining space after sidebar */
      display: flex;                                       /* Flexbox layout */
      flex-direction: column;                              /* Stack elements vertically */
      align-items: center;                                 /* Center content horizontally */
      padding: 20px;                                       /* Padding around content */
    }
    
    /* Main title of the office board page */
    .board-title {
      margin-bottom: 20px;                                 /* Space below title */
      color: white;                                        /* White text for dark theme */
      font-size: 2rem;                                     /* Large, prominent title */
      font-weight: bold;                                   /* Bold weight for emphasis */
      text-align: center;                                  /* Center-aligned text */
      width: 100%;                                         /* Full width */
    }
    
    /* ===== BOARD HEADER AND STATISTICS ===== */
    /* Header section containing statistics and status legend */
    .board-header {
      display: flex;                                       /* Flexbox layout */
      justify-content: center;                             /* Center content horizontally */
      align-items: center;                                 /* Center content vertically */
      margin-bottom: 20px;                                 /* Space below header */
      flex-wrap: wrap;                                     /* Allow wrapping on small screens */
      gap: 20px;                                           /* Space between elements */
      position: relative;                                  /* Positioning context */
      width: 100%;                                         /* Full width */
    }
    
    /* Container for statistics display */
    .board-stats {
      display: flex;                                       /* Flexbox layout */
      gap: 20px;                                           /* Space between stat items */
      flex-wrap: wrap;                                     /* Allow wrapping on small screens */
      justify-content: center;                             /* Center stats horizontally */
    }
    
    /* Individual statistic item (e.g., "Total Active: 5") */
    .stat-item {
      background: rgba(255, 255, 255, 0.1);               /* Semi-transparent white background */
      padding: 10px 15px;                                 /* Comfortable padding */
      border-radius: 8px;                                  /* Rounded corners */
      text-align: center;                                  /* Center text */
      min-width: 80px;                                     /* Minimum width for consistency */
    }
    
    /* Label text for statistics (e.g., "Total Active") */
    .stat-label {
      font-size: 0.8rem;                                  /* Smaller text for labels */
      opacity: 0.8;                                        /* Slightly transparent */
      margin-bottom: 5px;                                  /* Space below label */
      display: block;                                      /* Block display */
    }
    
    /* Value text for statistics (e.g., "5") */
    .stat-value {
      font-size: 1.2rem;                                  /* Larger text for values */
      font-weight: bold;                                   /* Bold weight for emphasis */
    }
    
    /* ===== STATUS LEGEND ===== */
    /* Legend showing what different status colors mean */
    .status-legend {
      background: rgba(255, 255, 255, 0.95);              /* Nearly opaque white background */
      padding: 15px;                                       /* Comfortable padding */
      border-radius: 12px;                                 /* Rounded corners */
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);            /* Subtle shadow for depth */
      min-width: 200px;                                    /* Minimum width for content */
    }
    
    /* Legend title */
    .status-legend h3 {
      margin: 0 0 10px 0;                                  /* Space below title */
      color: #333;
      font-size: 1.1rem;
      font-weight: 600;
    }
    
    /* Container for legend items */
    .legend-items {
      display: flex;                                       /* Flexbox layout */
      flex-direction: column;                              /* Stack items vertically */
      gap: 8px;                                            /* Space between legend items */
    }
    
    /* Individual legend item (status + color circle) */
    .legend-item {
      display: flex;                                       /* Flexbox layout */
      align-items: center;                                 /* Center items vertically */
      gap: 8px;                                            /* Space between circle and text */
      font-size: 0.9rem;                                   /* Appropriate text size */
      color: #555;                                          /* Dark gray text */
    }
    
    /* Colored circles representing different user statuses */
    .status-circle {
      width: 12px;                                         /* Circle width */
      height: 12px;                                        /* Circle height */
      border-radius: 50%;                                  /* Make it perfectly round */
      display: inline-block;                               /* Inline block for layout */
    }
    
    /* Status-specific colors for visual identification */
    .status-circle.clocked-in {
      background-color: #28a745;                           /* Green - indicates active work */
    }
    
    .status-circle.break {
      background-color: #ffc107;                           /* Yellow - indicates break time */
    }
    
    .status-circle.work-from-home {
      background-color: #17a2b8;                           /* Blue - indicates remote work */
    }
    
    .status-circle.job-site {
      background-color: #8B4513;                           /* Brown - indicates off-site work */
    }
    
    .status-circle.clocked-out {
      background-color: #dc3545;                           /* Red - indicates not working */
    }
    
    /* ===== CANVAS CONTAINER ===== */
    /* Container for the interactive office layout canvas */
    .canvas-container {
      position: relative;                                  /* Positioning context for overlays */
      overflow: hidden;                                    /* Hide content outside boundaries */
      border-radius: 16px;                                 /* Rounded corners for modern look */
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);           /* Subtle shadow for depth */
      z-index: 200;                                        /* Above other content */
    }
    
    /* ===== FULLSCREEN SUPPORT ===== */
    /* CSS rules for when canvas is in fullscreen mode */
    /* Standard fullscreen API */
    #boardCanvas:fullscreen {
      width: 100vw;                                        /* Full viewport width */
      height: 100vh;                                       /* Full viewport height */
      margin: 0;                                           /* No margins */
      border: none;                                        /* No border */
      border-radius: 0;                                    /* No rounded corners */
      box-shadow: none;                                    /* No shadow */
    }
    
    /* Webkit browser fullscreen support (Chrome, Safari) */
    #boardCanvas:-webkit-full-screen {
      width: 100vw;                                        /* Full viewport width */
      height: 100vh;                                       /* Full viewport height */
      margin: 0;                                           /* No margins */
      border: none;                                        /* No border */
      border-radius: 0;                                    /* No rounded corners */
      box-shadow: none;                                    /* No shadow */
    }
    
    /* Firefox fullscreen support */
    #boardCanvas:-moz-full-screen {
      width: 100vw;                                        /* Full viewport width */
      height: 100vh;                                       /* Full viewport height */
      margin: 0;                                           /* No margins */
      border: none;                                        /* No border */
      border-radius: 0;                                    /* No rounded corners */
      box-shadow: none;                                    /* No shadow */
    }
    
    /* Internet Explorer/Edge fullscreen support */
    #boardCanvas:-ms-fullscreen {
      width: 100vw;                                        /* Full viewport width */
      height: 100vh;                                       /* Full viewport height */
      margin: 0;
      border: none;
      border-radius: 0;
      box-shadow: none;
    }
    
    /* ===== CENTER STATISTICS ===== */
    /* Prominent statistics displayed in the center of the board */
    .center-stats {
      display: flex;                                       /* Flexbox layout */
      justify-content: center;                             /* Center horizontally */
      margin: 20px 0;                                     /* Vertical spacing */
    }
    
    /* Special styling for center statistics to make them stand out */
    .center-stat {
      background: linear-gradient(135deg, #28a745, #20c997); /* Green gradient background */
      color: white;                                        /* White text for contrast */
      box-shadow: 0 4px 16px rgba(40, 167, 69, 0.3);     /* Green-tinted shadow */
      transform: scale(1.1);                               /* Slightly larger than other stats */
    }
    
    /* Ensure text is white in center stats */
    .center-stat .stat-label,
    .center-stat .stat-value {
      color: white;                                        /* White text for gradient background */
    }
    
    /* ===== BOARD CONTROLS ===== */
    /* Control buttons for canvas operations (zoom, refresh, etc.) */
    .board-controls {
      display: flex;                                       /* Flexbox layout */
      justify-content: center;                             /* Center horizontally */
      gap: 12px;                                           /* Space between buttons */
      margin-top: 20px;                                    /* Space above controls */
      flex-wrap: wrap;                                     /* Allow wrapping on small screens */
    }
    
    /* Individual control button styling */
    .control-btn {
      background: #2d2e4b;                                 /* Dark blue background */
      color: white;                                        /* White text */
      border: none;                                        /* No border */
      padding: 10px 16px;                                  /* Comfortable padding */
      border-radius: 6px;                                  /* Rounded corners */
      cursor: pointer;                                     /* Pointer cursor */
      font-size: 14px;                                     /* Appropriate text size */
      font-weight: 500;                                    /* Medium weight */
      transition: background-color 0.3s;                   /* Smooth color transition */
    }
    
    /* Hover effect for control buttons */
    .control-btn:hover {
      background: #1a1b2e;                                 /* Darker blue on hover */
    }

    /* ===== USER INFO MODAL ===== */
    /* Modal popup that displays detailed user information */
    .user-info-modal {
      position: fixed;                                     /* Fixed position over everything */
      z-index: 2000;                                       /* Very high z-index */
      left: 0;                                             /* Full width */
      top: 0;                                              /* Full height */
      width: 100%;                                         /* Cover entire viewport */
      height: 100%;                                        /* Cover entire viewport */
      background-color: rgba(0, 0, 0, 0.5);               /* Semi-transparent black overlay */
      display: none;                                       /* Hidden by default */
      align-items: center;                                 /* Center vertically */
      justify-content: center;                             /* Center horizontally */
    }
    
    /* Content container within the modal */
    .user-info-content {
      background: white;                                   /* White background */
      padding: 30px;                                       /* Generous padding */
      border-radius: 16px;                                 /* Rounded corners */
      max-width: 500px;                                    /* Maximum width */
      width: 90%;                                          /* Responsive width */
      max-height: 80vh;                                    /* Maximum height (80% of viewport) */
      overflow-y: auto;                                    /* Scrollable if content is too long */
      position: relative;                                  /* Positioning context */
    }
    
    /* Modal title styling */
    .user-info-content h3 {
      margin-top: 0;                                       /* No top margin */
      color: #333;                                         /* Dark text */
      font-size: 1.5rem;                                   /* Large title */
      margin-bottom: 20px;                                 /* Space below title */
    }
    
    /* Individual information item within the modal */
    .user-info-item {
      display: flex;                                       /* Flexbox layout */
      justify-content: space-between;                      /* Space between label and value */
      margin-bottom: 15px;                                 /* Space between items */
      padding: 10px;                                       /* Internal padding */
      background: #f8f9fa;                                 /* Light gray background */
      border-radius: 8px;                                  /* Rounded corners */
    }
    
    /* Label text within user info items */
    .user-info-label {
      font-weight: bold;                                   /* Bold text for labels */
      color: #2d2e4b;                                      /* Dark blue color matching theme */
    }
    
    /* Value text within user info items */
    .user-info-value {
      color: #6c757d;                                      /* Medium gray for values */
    }
    
    /* ===== STATUS CHANGE STYLING ===== */
    /* Status change dropdown styling */
    #statusChangeSelect {
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    
    #statusChangeSelect:focus {
      outline: none;
      border-color: #2d2e4b;
      box-shadow: 0 0 0 2px rgba(45, 46, 75, 0.2);
    }
    
    /* Status update button styling */
    #updateStatusBtn {
      background: #2d2e4b;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    #updateStatusBtn:hover:not(:disabled) {
      background: #1a1b2e;
    }
    
    #updateStatusBtn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    /* Status update message styling */
    #statusUpdateMessage {
      font-size: 12px;
      margin-top: 2px;
      min-height: 12px;
    }

    /* ===== BUTTON STYLES ===== */
    /* Primary action button styling */
    .confirm-btn {
      background-color: #2d2e4b;                           /* Dark blue background */
      color: white;                                        /* White text */
      border: none;                                        /* No border */
      padding: 10px 20px;                                  /* Comfortable padding */
      border-radius: 8px;                                  /* Rounded corners */
      font-size: 16px;                                     /* Readable text size */
      font-weight: 600;                                    /* Semi-bold weight */
      cursor: pointer;                                     /* Pointer cursor */
      transition: background-color 0.3s;                   /* Smooth color transition */
    }
    
    /* Hover effect for confirm button */
    .confirm-btn:hover {
      background-color: #1a1b2e;                           /* Darker blue on hover */
    }
    
    /* Close button with smooth opacity transition */
    .close-x-btn {
      transition: opacity 0.2s ease;                       /* Quick opacity transition */
    }
    
    /* Hover effect for close button */
    .close-x-btn:hover {
      opacity: 0.7;                                        /* Slightly transparent on hover */
    }
    
    /* ===== RESPONSIVE DESIGN - MOBILE DEVICES ===== */
    /* iPhone and small phones (up to 428px) */
    @media screen and (max-width: 428px) {
      :root {
        --scale-phone: 0.75;
        --scale-tablet: 0.8;
        --scale-desktop: 0.85;
        --scale-tv: 0.9;
      }
      
      body {
        font-size: calc(14px * var(--scale-phone));
        padding-left: calc(100px * var(--scale-phone)) !important;
        padding-top: calc(50px * var(--scale-phone)) !important;
      }
      
      .board-container {
        padding: calc(10px * var(--scale-phone)) !important;
        margin: calc(10px * var(--scale-phone)) !important;
        max-width: calc(100vw - 20px) !important;
        width: calc(100vw - 20px) !important;
        overflow-x: hidden !important;
        box-sizing: border-box !important;
      }
      
      .board-title {
        font-size: calc(1.5rem * var(--scale-phone));
        margin-bottom: calc(15px * var(--scale-phone));
      }
      
      .board-header {
        flex-direction: column;
        align-items: center;
        margin-bottom: calc(15px * var(--scale-phone));
        gap: calc(10px * var(--scale-phone));
      }
      
      .status-legend {
        order: 1;
        align-self: flex-start;
        margin-bottom: calc(10px * var(--scale-phone));
      }
      
      .board-title {
        order: 2;
      }
      
      .board-stats {
        order: 3;
      }
      
      .board-stats {
        gap: calc(8px * var(--scale-phone));
        justify-content: center;
        width: 100%;
        flex-wrap: wrap;
      }
      
      .stat-item {
        min-width: calc(70px * var(--scale-phone));
        padding: calc(6px * var(--scale-phone)) calc(8px * var(--scale-phone));
      }
      
      .stat-label {
        font-size: calc(0.7rem * var(--scale-phone));
        margin-bottom: calc(2px * var(--scale-phone));
      }
      
      .stat-value {
        font-size: calc(1rem * var(--scale-phone));
      }
      
      .canvas-container {
        border-radius: calc(12px * var(--scale-phone));
        box-shadow: 0 calc(2px * var(--scale-phone)) calc(12px * var(--scale-phone)) rgba(0,0,0,0.08);
        overflow: hidden;
        max-width: calc(100vw - 20px);
        width: calc(100vw - 20px);
        position: relative;
        z-index: 200;
      }
      
      #boardCanvas {
        width: calc(100vw - 20px) !important;
        height: auto !important;
        max-height: calc(60vh * var(--scale-phone));
        margin: calc(10px * var(--scale-phone)) auto !important;
        border-width: calc(2px * var(--scale-phone)) !important;
        border-radius: calc(12px * var(--scale-phone)) !important;
      }
      
      .board-controls {
        gap: calc(6px * var(--scale-phone));
        margin-top: calc(15px * var(--scale-phone));
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .control-btn {
        padding: calc(8px * var(--scale-phone)) calc(12px * var(--scale-phone));
        font-size: calc(12px * var(--scale-phone));
        border-radius: calc(4px * var(--scale-phone));
      }
      
      /* Status Legend Mobile Scaling */
      .status-legend {
        padding: calc(10px * var(--scale-phone));
        min-width: calc(150px * var(--scale-phone));
        position: absolute;
        left: calc(10px * var(--scale-phone));
        top: calc(-80px * var(--scale-phone));
        transform: scale(var(--scale-phone));
        transform-origin: top left;
      }
      
      .status-legend h3 {
        font-size: calc(0.9rem * var(--scale-phone));
        margin-bottom: calc(8px * var(--scale-phone));
      }
      
      .legend-items {
        gap: calc(6px * var(--scale-phone));
      }
      
      .legend-item {
        gap: calc(6px * var(--scale-phone));
        font-size: calc(0.75rem * var(--scale-phone));
      }
      
      .status-circle {
        width: calc(10px * var(--scale-phone));
        height: calc(10px * var(--scale-phone));
      }
      
      .left-sidebar {
        width: calc(100px * var(--scale-phone));
        height: 100vh;
        min-height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      
      .sidebar-toggle {
        font-size: calc(2rem * var(--scale-phone));
        width: calc(60px * var(--scale-phone));
        height: calc(60px * var(--scale-phone));
      }
    }
  </style>
</head>
<body>
  <!-- ===== LEFT SIDEBAR NAVIGATION ===== -->
  <!-- Collapsible sidebar providing navigation to different app sections -->
  <div class="left-sidebar" id="leftSidebar">
    <!-- Sidebar header with toggle functionality -->
    <div class="sidebar-header" onclick="toggleSidebar()">
      <h3>Menu</h3>                                          <!-- Menu text (visible when expanded) -->
      <div class="sidebar-toggle" id="sidebarToggle">&#9776;</div>  <!-- Hamburger menu icon -->
    </div>
    
    <!-- Close button (visible when sidebar is expanded) -->
    <button class="sidebar-close" id="sidebarClose" onclick="toggleSidebar()">‚úï</button>
    
    <!-- ===== ICON-BASED NAVIGATION ===== -->
    <!-- Navigation using emoji icons (visible when sidebar is collapsed) -->
    <div class="sidebar-icons" id="sidebarIcons">
      <a href="#" class="sidebar-icon-item" id="dashboardIcon" title="Dashboard">
        <span class="icon">üìä</span>                          <!-- Dashboard icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="boardIcon" title="Board">
        <span class="icon">üìã</span>                          <!-- Board icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="settingsIcon" title="Settings">
        <span class="icon">‚öôÔ∏è</span>                          <!-- Settings icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="submitIcon" title="Submit Email">
        <span class="icon">üìß</span>                          <!-- Submit email icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="viewEmailIcon" title="View Email">
        <span class="icon">üì¨</span>                          <!-- View email icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="hoursIcon" title="Hours">
        <span class="icon">‚è±Ô∏è</span>                          <!-- Hours tracking icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="editUsersIcon" title="Edit Users">
        <span class="icon">üë•</span>                          <!-- User management icon -->
      </a>
      <a href="#" class="sidebar-icon-item" id="signOutIcon" title="Sign Out">
        <span class="icon">üö™</span>                          <!-- Sign out icon -->
      </a>
    </div>
    
    <!-- ===== TEXT-BASED NAVIGATION ===== -->
    <!-- Navigation using text links (visible when sidebar is expanded) -->
    <div class="sidebar-text" id="sidebarText" style="display: none;">
      <a href="#" id="dashboardLink">Dashboard</a>            <!-- Dashboard link -->
      <a href="#" id="boardLink">Board</a>                   <!-- Board link -->
      <a href="#" id="settingsLink">Settings</a>             <!-- Settings link -->
      <a href="#" id="submitLink">Submit Email</a>           <!-- Submit email link -->
      <a href="#" id="viewEmailLink">View Email</a>          <!-- View email link -->
      <a href="#" id="hourLink">Hours</a>                    <!-- Hours link -->
      <a href="#" id="editUsersLink">Edit Users</a>          <!-- User management link -->
      <a href="#" id="signOutLink">Sign Out</a>              <!-- Sign out link -->
    </div>
  </div>
  
  <!-- ===== MAIN BOARD CONTENT ===== -->
  <!-- Container for the office board visualization and controls -->
  <div class="board-container">
    <!-- Main page title -->
    <h1 class="board-title">Office Presence Board</h1>
    
    <!-- ===== BOARD HEADER SECTION ===== -->
    <!-- Contains status legend and real-time statistics -->
    <div class="board-header">
      <!-- ===== STATUS LEGEND ===== -->
      <!-- Visual guide explaining what different status colors mean -->
      <div class="status-legend">
        <h3>Status Legend</h3>                               <!-- Legend title -->
        <div class="legend-items">
          <div class="legend-item">
            <div class="status-circle clocked-in"></div>      <!-- Green circle for active work -->
            <span>Clocked In</span>                          <!-- Status description -->
          </div>
          <div class="legend-item">
            <div class="status-circle break"></div>           <!-- Yellow circle for break time -->
            <span>On Break</span>                            <!-- Status description -->
          </div>
          <div class="legend-item">
            <div class="status-circle work-from-home"></div>  <!-- Blue circle for remote work -->
            <span>Work from Home</span>                       <!-- Status description -->
          </div>
          <div class="legend-item">
            <div class="status-circle job-site"></div>        <!-- Brown circle for off-site work -->
            <span>Job Site</span>                            <!-- Status description -->
          </div>
          <div class="legend-item">
            <div class="status-circle clocked-out"></div>     <!-- Red circle for not working -->
            <span>Clocked Out</span>                         <!-- Status description -->
          </div>
        </div>
      </div>
      
      <!-- ===== REAL-TIME STATISTICS ===== -->
      <!-- Live counters showing current office status -->
      <div class="board-stats">
        <div class="stat-item">
          <span class="stat-label">Total Active:</span>       <!-- Label for total active users -->
          <span class="stat-value" id="totalActive">0</span>  <!-- Dynamic value updated by JavaScript -->
        </div>
        <div class="stat-item">
          <span class="stat-label">Clocked In:</span>         <!-- Label for clocked-in users -->
          <span class="stat-value" id="clockedInCount">0</span> <!-- Dynamic value updated by JavaScript -->
        </div>
        <div class="stat-item">
          <span class="stat-label">On Break:</span>           <!-- Label for users on break -->
          <span class="stat-value" id="breakCount">0</span>   <!-- Dynamic value updated by JavaScript -->
        </div>
        <div class="stat-item">
          <span class="stat-label">Last Updated:</span>       <!-- Label for last update time -->
          <span class="stat-value" id="lastUpdated">--</span> <!-- Dynamic timestamp updated by JavaScript -->
        </div>
      </div>
    </div>
    
    <!-- ===== INTERACTIVE CANVAS CONTAINER ===== -->
    <!-- Container for the office layout visualization -->
    <div class="canvas-container">
      <!-- HTML5 Canvas element for drawing the office layout -->
      <!-- Width: 1100px, Height: 700px for optimal viewing -->
      <!-- Styled with border, shadow, and grab cursor for interaction -->
      <canvas id="boardCanvas" width="1100" height="700" style="display:block; margin: 40px auto; background: transparent; border: 3px solid #333333; border-radius: 16px; box-shadow: 0 4px 24px rgba(0,0,0,0.08); cursor: grab;"></canvas>
    </div>
    
    <!-- ===== BOARD CONTROL BUTTONS ===== -->
    <!-- Interactive controls for the office board -->
    <div class="board-controls">
      <button id="refreshBtn" class="control-btn">üîÑ Refresh</button>      <!-- Refresh button to reload data -->
      <button id="fullscreenBtn" class="control-btn">‚õ∂ Fullscreen</button> <!-- Fullscreen button for immersive view -->
    </div>
  </div>

  <!-- ===== USER INFORMATION MODAL ===== -->
  <!-- Popup modal that displays detailed user information when clicking on a user -->
  <div id="userInfoModal" class="user-info-modal">
    <div class="user-info-content">
      <h3 id="userInfoTitle">User Information</h3>              <!-- Modal title -->
      <div id="userInfoDetails">
        <!-- User information will be dynamically populated here by JavaScript -->
      </div>
      <!-- Close button for the modal -->
      <button id="closeUserInfo" class="close-x-btn" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 5px;">‚úï</button>
    </div>
  </div>

  <!-- ===== JAVASCRIPT FUNCTIONALITY ===== -->
  <script defer>
    // ===== SIDEBAR FUNCTIONALITY =====
    // Function to toggle the sidebar between collapsed and expanded states
    function toggleSidebar() {
      console.log('Sidebar toggle clicked!');                    // Debug logging
      const sidebar = document.getElementById('leftSidebar');      // Get sidebar element
      const icons = document.getElementById('sidebarIcons');      // Get icon navigation container
      const text = document.getElementById('sidebarText');        // Get text navigation container
      
      if (sidebar.classList.contains('expanded')) {
        // Close the sidebar - return to collapsed state
        sidebar.classList.remove('expanded');                     // Remove expanded class
        icons.style.display = 'block';                           // Show icon navigation
        text.style.display = 'none';                             // Hide text navigation
        document.body.style.paddingLeft = '100px';               // Adjust body padding for collapsed sidebar
        console.log('Sidebar closed');                           // Debug logging
      } else {
        // Open the sidebar - expand to show text labels
        sidebar.classList.add('expanded');                       // Add expanded class
        icons.style.display = 'none';                            // Hide icon navigation
        text.style.display = 'block';                            // Show text navigation
        document.body.style.paddingLeft = '200px';               // Adjust body padding for expanded sidebar
        console.log('Sidebar opened');                           // Debug logging
      }
    }

    // ===== APPLICATION INITIALIZATION =====
    // Main initialization function that runs when the DOM is fully loaded
    document.addEventListener("DOMContentLoaded", () => {
      // ===== URL PARAMETER HANDLING =====
      // Function to extract query parameters from the URL
      function getQueryParam(name) {
        const urlParams = new URLSearchParams(window.location.search);  // Parse URL query string
        return urlParams.get(name);                                     // Return specific parameter value
      }
      
      // Get username from URL parameters for user authentication
      const username = getQueryParam('username');
      
      // ===== SIDEBAR NAVIGATION SETUP =====
      // Configure sidebar navigation links if user is authenticated
      if (username) {
        setupSidebarIconLinks(username);                                // Set up navigation links
        
        // ===== ADMIN ROLE DETECTION =====
        // Fetch user info to determine if they have admin privileges
        fetch(`${window.ApiUrlLink}/user/${username}`)
          .then(res => res.json())                                      // Parse response as JSON
          .then(user => {
            if (user && user.role === 'admin') {
              // Show admin-only features for admin users
              document.getElementById('hourLink').style.display = 'block';      // Show hours link
              document.getElementById('hoursIcon').style.display = 'flex';      // Show hours icon
            } else {
              // Hide admin features for regular users
              document.getElementById('hourLink').style.display = 'none';       // Hide hours link
              document.getElementById('hoursIcon').style.display = 'none';      // Hide hours icon
            }
            // Note: Edit Users link is now visible to everyone for better accessibility
          });
      }
      
      // ===== SIDEBAR INTERACTION SETUP =====
      // Set up click event listeners for sidebar toggle functionality
      const sidebarToggle = document.getElementById('sidebarToggle');     // Get toggle button
      const sidebarHeader = document.querySelector('.sidebar-header');   // Get header container
      
      if (sidebarToggle) {
        sidebarToggle.addEventListener('click', function(e) {
          e.stopPropagation();                                          // Prevent event bubbling
      toggleSidebar();
    });
  }
  
  if (sidebarHeader) {
    sidebarHeader.addEventListener('click', function(e) {
      e.stopPropagation();
      toggleSidebar();
    });
  }
});

function setupSidebarIconLinks(username) {
  // Set href attributes for sidebar icons
  document.getElementById('dashboardIcon').href = `dashboard.html?username=${encodeURIComponent(username)}`;
  document.getElementById('boardIcon').href = `board.html?username=${encodeURIComponent(username)}`;
  document.getElementById('settingsIcon').href = `settings.html?username=${encodeURIComponent(username)}`;
  document.getElementById('submitIcon').href = `submit_email.html?username=${encodeURIComponent(username)}`;
  document.getElementById('viewEmailIcon').href = `view_email.html?username=${encodeURIComponent(username)}`;
  document.getElementById('hoursIcon').href = `hours.html?username=${encodeURIComponent(username)}`;
  document.getElementById('editUsersIcon').href = `users.html?username=${encodeURIComponent(username)}`;
  
  // Set href attributes for sidebar text links
  document.getElementById('dashboardLink').href = `dashboard.html?username=${encodeURIComponent(username)}`;
  document.getElementById('boardLink').href = `board.html?username=${encodeURIComponent(username)}`;
  document.getElementById('settingsLink').href = `settings.html?username=${encodeURIComponent(username)}`;
  document.getElementById('submitLink').href = `submit_email.html?username=${encodeURIComponent(username)}`;
  document.getElementById('viewEmailLink').href = `view_email.html?username=${encodeURIComponent(username)}`;
  document.getElementById('hourLink').href = `hours.html?username=${encodeURIComponent(username)}`;
  document.getElementById('editUsersLink').href = `users.html?username=${encodeURIComponent(username)}`;
  
  // Set up sign out functionality for both icon and text
  document.getElementById('signOutIcon').onclick = function(e) {
    e.preventDefault();
    localStorage.removeItem('user');
    window.location.href = 'index.html';
  };
  

  
  // Hide board navigation since we're already on the board page
  document.getElementById('boardIcon').style.display = 'none';
  document.getElementById('boardLink').style.display = 'none';
}

// --- End Sidebar logic ---

document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('boardCanvas');
  const ctx = canvas.getContext('2d');

  // Load images globally so they can be accessed by drawOfficeWithUsers
  window.deskImg = new Image();
  window.deskImg.src = `${document.baseURI}Static/Images/Desks/desk.png`;
  
  window.deskOpImg = new Image();
  window.deskOpImg.src = `${document.baseURI}Static/Images/Desks/deskop.png`;

  // Wait for images to load
  Promise.all([window.deskImg.decode(), window.deskOpImg.decode()]).then(() => {
    // Clear canvas with transparent background
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Load newbackground.png as layout guide and store it globally
    const layoutImg = new Image();
    layoutImg.onload = function() {
      // Store the image globally so it can be used in drawOfficeWithUsers
      window.layoutBackgroundImage = layoutImg;
      
      // Draw grid on canvas
      drawGrid();
      
      // Note: Background image will be drawn by the existing drawOfficeWithUsers function
      // so we don't need to draw it here to avoid duplication
      
      console.log('New desk layout canvas ready for development - newbackground.png loaded and ready for use');
    };
    layoutImg.src = `${document.baseURI}Static/Images/Background/newbackground.png`;
    
    // Function to draw grid on canvas
    function drawGrid() {
      const gridSize = 64; // Grid cell size in pixels (matches desk positions)
      const gridColor = 'rgba(255, 255, 255, 0.3)'; // Light white with transparency
      const gridLineWidth = 1;
      
      ctx.save();
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = gridLineWidth;
      
      // Draw vertical lines
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    // Start the application after images are loaded
    // Fetch users and update boardUsers, then start animation
    refreshData();
    

  }).catch(error => {
    console.error('Error loading images:', error);
  });

  // --- Drawing Logic ---
  // Global users array for animation
  let boardUsers = [];

  // Global variables for zoom and pan
  let zoomLevel = 1;
  let panX = 0;
  let panY = 0;
  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;

  // Animation variables
  let frameIndex = 0;
  let lastFrameTime = 0;
  const frameDuration = 200; // ms per frame

  // Character sprite config
  const spriteSheet = new Image();
  spriteSheet.src = `${document.baseURI}Static/Images/Characters/Boy_idle.png`;
  
  const frameWidth = 48;
  const frameHeight = 48;
  const totalFrames = 4;

  // Constants
  const gridCols = 22; // number of columns in your grid (positions 0-21)
  const gridRows = 8; // number of rows in your grid (reduced to match your layout)
  const cellSize = 64; // pixels per grid cell

  // Desk positions from the provided text grid (x = column, y = row, 0-indexed)
  // Desk positions from new_desklayout.html with rotation support
  const deskPositions = [
    // Buddies Row 0: xoxox
    {x:2.7, y:1, rotation: 0, deskType: 'desk'}, {x:5, y:1.3, rotation: 0, deskType: 'desk'},
    // Row 1: oxxx
    {x:0.9, y:2.5, rotation: 0, deskType: 'desk'},
    // Row 2: oxxoxxxo
    {x:0.9, y:3.7, rotation: 0, deskType: 'desk'}, {x:4.2, y:3.4, rotation: 0, deskType: 'deskop'}, {x:8, y:4, rotation: 0, deskType: 'deskop'},
    // Row 3: xxxxxxxxxxoxxoxxo
    {x:2.1, y:7.7, rotation: -45, deskType: 'desk'}, {x:2.6, y:8.2, rotation: -45, deskType: 'desk'}, 

    {x:5.1, y:8.4, rotation: 0, deskType: 'deskop'}, {x:5.1, y:9.1, rotation: 0, deskType: 'deskop'}, {x:4.3, y:9.1, rotation: 0, deskType: 'desk'}, {x:4.3, y:8.4, rotation: 0, deskType: 'desk'},  
    
    {x:7.5, y:8.2, rotation: 0, deskType: 'deskop'}, {x:7.5, y:8.9, rotation: 0, deskType: 'deskop'}, {x:6.7, y:8.2, rotation: 0, deskType: 'desk'}, {x:6.7, y:8.9, rotation: 0, deskType: 'desk'},

    {x:10.1, y:8.4, rotation: 0, deskType: 'deskop'}, {x:10.1, y:9.1, rotation: 0, deskType: 'deskop'}, {x:9.3, y:9.1, rotation: 0, deskType: 'desk'}, {x:9.3, y:8.4, rotation: 0, deskType: 'desk'},

    {x:12.2, y:8.5, rotation: 0, deskType: 'deskop'}, {x:12.2, y:9.2, rotation: 0, deskType: 'deskop'}, {x:11.4, y:8.5, rotation: 0, deskType: 'desk'}, {x:11.4, y:9.2, rotation: 0, deskType: 'desk'},
    
    {x:14.35, y:8.2, rotation: 0, deskType: 'deskop'}, {x:14.35, y:8.9, rotation: 0, deskType: 'deskop'}, {x:13.6, y:8.2, rotation: 0, deskType: 'desk'}, {x:13.6, y:8.9, rotation: 0, deskType: 'desk'},

    {x:15.5, y:7.6, rotation: 0, deskType: 'desk'}, {x:15.5, y:9.3, rotation: 0, deskType: 'desk'},
    // Row 4: oxxxx
    {x:11, y:6.1, rotation: 0, deskType: 'desk'}, {x:12.2, y:6.1, rotation: 0, deskType: 'desk'},{x:13.5, y:6.1, rotation: 0, deskType: 'desk'},
  ];

// Function to update statistics
function updateStats(users) {
  const activeUsers = users.filter(user => 
    user.desk && (user.status === "clocked-in" || user.status === "break")
  );
  const clockedInUsers = users.filter(user => 
    user.desk && user.status === "clocked-in"
  );
  const breakUsers = users.filter(user => 
    user.desk && user.status === "break"
  );
  
  document.getElementById('totalActive').textContent = activeUsers.length;
  document.getElementById('clockedInCount').textContent = clockedInUsers.length;
  document.getElementById('breakCount').textContent = breakUsers.length;
  document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
}

// Function to refresh data
function refreshData() {
  fetch(`${window.ApiUrlLink}/users`)
    .then(res => res.json())
    .then(data => {
      boardUsers = data.users;
      updateStats(boardUsers);
      requestAnimationFrame(animateSprite);
    })
    .catch(error => {
      console.error('Error fetching users:', error);
    });
}

// refreshData() is now called after images load

// Auto-refresh every 30 seconds
setInterval(refreshData, 30000);

// Avatar animation configs
const avatarConfigs = {
  "City_men_idle.png": {
    frameWidth: 48,
    frameHeight: 48,
    totalFrames: 4,
    frameDuration: 200
  },
  "Boy_idle.png": {
    frameWidth: 48,
    frameHeight: 48,
    totalFrames: 4,
    frameDuration: 200
  }
};
const AVATAR_BOX_SIZE = 64;

// Avatar sprite cache
const avatarSpriteSheets = {};

function getAvatarSpriteSheet(file) {
  if (!avatarSpriteSheets[file]) {
    const img = new window.Image();
    img.src = `${document.baseURI}Static/Images/Characters/${file}`;
    avatarSpriteSheets[file] = img;
  }
  return avatarSpriteSheets[file];
}

// Per-user animation state
const userAnimStates = {};



function drawOfficeWithUsers(users) {
  // Apply zoom and pan transformations
  applyZoomAndPan();
  
  // Clear canvas with transparent background
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw newbackground.png as layout guide (same as new_desklayout.html)
  if (window.layoutBackgroundImage && window.layoutBackgroundImage.complete) {
    ctx.save();
    
    // Move to the center of the canvas for rotation
    ctx.translate(canvas.width / 2, canvas.height / 2);
    
    // Rotate 90 degrees to the left (counterclockwise)
    ctx.rotate(-Math.PI / 2);
    
    // Calculate scale to fit the rotated image and make it smaller
    const baseScale = Math.min(canvas.width / window.layoutBackgroundImage.height, canvas.height / window.layoutBackgroundImage.width);
    const scale = baseScale * 1.2; // Make it 20% bigger (smaller than before)
    const scaledWidth = window.layoutBackgroundImage.width * scale;
    const scaledHeight = window.layoutBackgroundImage.height * scale;
    
    // Draw the rotated image centered
    ctx.drawImage(window.layoutBackgroundImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
    
    // Restore the canvas context
    ctx.restore();
  }
  
  // Draw grid (optional, for visual reference)
  ctx.save();
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Light white with transparency
  for (let r = 0; r <= gridRows; r++) {
    ctx.beginPath();
    ctx.moveTo(0, r * cellSize);
    ctx.lineTo(canvas.width, r * cellSize);
    ctx.stroke();
  }
  for (let c = 0; c <= gridCols; c++) {
    ctx.beginPath();
    ctx.moveTo(c * cellSize, 0);
    ctx.lineTo(c * cellSize, canvas.height);
    ctx.stroke();
  }
  ctx.restore();

  // Draw desks with sizing and rotation from new_desklayout.html
  deskPositions.forEach((desk, index) => {
    const px = desk.x * cellSize;
    const py = desk.y * cellSize;
    
    // Scale desk images smaller (75% of original size) - same as new_desklayout.html
    const deskSize = cellSize * 0.75; // 48px instead of 64px
    const offsetX = (cellSize - deskSize) / 2; // Center the smaller desk in the cell
    const offsetY = (cellSize - deskSize) / 2;
    
    ctx.save();
    
    // Choose desk image based on deskType (if specified) or fall back to old logic
    let deskImage;
    if (desk.deskType === 'deskop') {
      deskImage = window.deskOpImg;
      console.log(`Desk at (${desk.x}, ${desk.y}): Using deskOpImg for deskType 'deskop'`);
    } else if (desk.deskType === 'desk') {
      deskImage = window.deskImg;
      console.log(`Desk at (${desk.x}, ${desk.y}): Using deskImg for deskType 'desk'`);
    } else {
      // Fall back to old logic for backward compatibility
      const useRegularDesk = [2, 6, 10, 14, 18, 21].includes(desk.x);
      deskImage = useRegularDesk ? window.deskImg : window.deskOpImg;
      console.log(`Desk at (${desk.x}, ${desk.y}): Fallback logic - useRegularDesk: ${useRegularDesk}, using ${useRegularDesk ? 'deskImg' : 'deskOpImg'}`);
    }
    
    // Debug: Check if images are loaded
    if (!window.deskImg || !window.deskOpImg) {
      console.error('Desk images not loaded yet!', {
        deskImg: window.deskImg,
        deskOpImg: window.deskOpImg
      });
    }
    
    // Move to desk center for rotation (if rotation is specified)
    if (desk.rotation !== undefined && desk.rotation !== 0) {
      ctx.translate(px + cellSize/2, py + cellSize/2);
      ctx.rotate(desk.rotation * Math.PI / 180);
      
      // Draw desk image centered at origin
      ctx.drawImage(deskImage, -deskSize/2, -deskSize/2, deskSize, deskSize);
    } else {
      // No rotation - draw desk image with offset to center it
      ctx.drawImage(
        deskImage,
        px + offsetX, py + offsetY,
        deskSize, deskSize
      );
    }
    
    ctx.restore();
    

  });

  // Draw users at their desks
  users.forEach(user => {
    if (!user.avatar) return;
    console.log(`User ${user.username}: status = ${user.status}, desk = ${user.desk}`);
    if (user.desk) {
      let deskCoord = user.desk;
      if (typeof deskCoord === "string") {
        const [x, y] = deskCoord.split(',').map(Number);
        deskCoord = {x, y};
      }
      const px = deskCoord.x * cellSize;
      const py = deskCoord.y * cellSize;
      const config = avatarConfigs[user.avatar] || avatarConfigs[Object.keys(avatarConfigs)[0]];
      const sequence = config.frameSequence || [...Array(config.totalFrames).keys()];
      const seqLen = sequence.length;
      const spriteSheet = getAvatarSpriteSheet(user.avatar);
      // Per-user animation state
      if (!userAnimStates[user.username]) {
        userAnimStates[user.username] = { frameIndex: 0, lastFrameTime: 0, seqIndex: 0 };
      }
      const state = userAnimStates[user.username];
      const now = performance.now();
      if (!state.lastFrameTime) state.lastFrameTime = now;
      const elapsed = now - state.lastFrameTime;
      if (elapsed > config.frameDuration) {
        state.seqIndex = (state.seqIndex + 1) % seqLen;
        state.lastFrameTime = now;
      }
      const frameToDraw = sequence[state.seqIndex];
      // Scale and center in 64x64 box
      const scale = Math.min(
        AVATAR_BOX_SIZE / config.frameWidth,
        AVATAR_BOX_SIZE / config.frameHeight
      );
      const drawWidth = config.frameWidth * scale;
      const drawHeight = config.frameHeight * scale;
      const offsetX = px + (cellSize - AVATAR_BOX_SIZE) / 2 + (AVATAR_BOX_SIZE - drawWidth) / 2;
      const offsetY = py + (cellSize - AVATAR_BOX_SIZE) / 2 + (AVATAR_BOX_SIZE - drawHeight) / 2;
      // Find the desk position to get deskType and rotation
      const deskPosition = deskPositions.find(desk => 
        Math.abs(desk.x - deskCoord.x) < 0.1 && Math.abs(desk.y - deskCoord.y) < 0.1
      );
      
      // Check if user is at a desk that uses desk.png (regular desk) or use deskType if available
      const useRegularDesk = deskPosition && deskPosition.deskType ? 
        deskPosition.deskType === 'desk' : 
        [2, 6, 10, 14, 18, 21].includes(deskCoord.x);
      
      // Adjust avatar positioning and direction based on desk type
      let avatarOffsetX = 6; // default pixels left (moved back to the right)
      let avatarOffsetY = -16; // pixels up (moved higher)
      
      // Draw house icon behind avatar and name for users working from home
      if (user.status === "work-from-home") {
        ctx.save();
        ctx.font = '60px Arial'; // Even bigger house icon
        ctx.fillStyle = '#17a2b8'; // Solid teal color
        ctx.textAlign = 'center';
        // Position house icon at the center of the desk, behind everything
        ctx.fillText('üè°', px + cellSize/2, py + cellSize/2 + 10);
        ctx.restore();
      }
      
      ctx.save();
      
      // Handle different statuses
      if (user.status === "break") {
        ctx.globalAlpha = 0.3; // faded
      } else if (user.status === "clocked-out") {
        ctx.globalAlpha = 0.1; // very faded for clocked out users
      }
      
      // Draw avatar for all users (including clocked-out with very low opacity)
      if (useRegularDesk) {
        // For regular desks (desk.png), use normal positioning
        ctx.drawImage(
          spriteSheet,
          frameToDraw * config.frameWidth, 0, config.frameWidth, config.frameHeight,
          offsetX + avatarOffsetX, offsetY + avatarOffsetY, drawWidth, drawHeight
        );
      } else {
        // For other desks (deskop.png), flip avatar horizontally and shift more to the right
        avatarOffsetX = -6; // more pixels right (moved left)
        ctx.scale(-1, 1); // flip horizontally
        ctx.drawImage(
          spriteSheet,
          frameToDraw * config.frameWidth, 0, config.frameWidth, config.frameHeight,
          -(offsetX + avatarOffsetX + drawWidth), offsetY + avatarOffsetY, drawWidth, drawHeight
        );
        ctx.restore(); // Restore canvas state after flipped avatar
        ctx.save(); // Save state for name tag
      }
      ctx.globalAlpha = 1.0;
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      
      // Draw username with white text, dark blue fill, and white border
      const username = user.username;
      const textX = px + cellSize/2 - 10;
      const textY = py + cellSize - 50;
      
      // Measure text for background sizing
      const textMetrics = ctx.measureText(username);
      const textWidth = textMetrics.width;
      const textHeight = 14; // Smaller height for tighter fit
      const padding = 2; // Smaller padding for more centered look
      const borderWidth = 1; // Border width
      
      // Draw dark blue fill
      ctx.fillStyle = '#2d2e4b'; // Dark blue fill
      ctx.fillRect(
        textX - textWidth/2 - padding, 
        textY - textHeight - padding, 
        textWidth + padding * 2, 
        textHeight + padding * 2
      );
      
      // Draw white border
      ctx.strokeStyle = '#ffffff'; // White border
      ctx.lineWidth = borderWidth;
      ctx.strokeRect(
        textX - textWidth/2 - padding, 
        textY - textHeight - padding, 
        textWidth + padding * 2, 
        textHeight + padding * 2
      );
      
      // Draw white text
      ctx.fillStyle = '#ffffff'; // White text
      ctx.fillText(username, textX, textY);
      
      // Draw status circle in top right corner of name tag
      const circleRadius = 4;
      const circleX = textX + textWidth/2 + padding + circleRadius - 4; // Moved a little to the left
      const circleY = textY - textHeight - padding - circleRadius + 2; // Moved a little down
      
      // Set status circle color based on user status
      let statusColor;
      switch(user.status) {
        case 'clocked-in':
          statusColor = '#28a745'; // Green
          break;
        case 'break':
          statusColor = '#ffc107'; // Yellow
          break;
        case 'work-from-home':
          statusColor = '#17a2b8'; // Blue
          break;
        case 'job-site':
          statusColor = '#8B4513'; // Brown
          break;
        case 'clocked-out':
          statusColor = '#dc3545'; // Red
          break;
        default:
          statusColor = '#6c757d'; // Gray for unknown status
      }
      
      // Draw status circle
      ctx.beginPath();
      ctx.arc(circleX, circleY, circleRadius, 0, 2 * Math.PI);
      ctx.fillStyle = statusColor;
      ctx.fill();
      ctx.strokeStyle = '#2d2e4b';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
  });
  
  // Reset zoom and pan transformations
  resetZoomAndPan();
}

function animateSprite(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  const elapsed = timestamp - lastFrameTime;
  if (elapsed > frameDuration) {
    frameIndex = (frameIndex + 1) % totalFrames;
    lastFrameTime = timestamp;
  }
  drawOfficeWithUsers(boardUsers);
  requestAnimationFrame(animateSprite);
}

// Zoom and Pan Functions
function applyZoomAndPan() {
  ctx.save();
  ctx.translate(panX, panY);
  ctx.scale(zoomLevel, zoomLevel);
}

function resetZoomAndPan() {
  ctx.restore();
}

// Zoom controls
function zoomIn() {
  zoomLevel = Math.min(zoomLevel * 1.2, 3);
}

function zoomOut() {
  zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
}

function resetZoom() {
  zoomLevel = 1;
  panX = 0;
  panY = 0;
}

// Fullscreen function
function toggleFullscreen() {
  const canvas = document.getElementById('boardCanvas');
  
  // Check if fullscreen is supported
  if (!document.fullscreenEnabled && 
      !document.webkitFullscreenEnabled && 
      !document.mozFullScreenEnabled && 
      !document.msFullscreenEnabled) {
    alert('Fullscreen is not supported in this browser');
    return;
  }
  
  // Check if already in fullscreen
  if (!document.fullscreenElement && 
      !document.webkitFullscreenElement && 
      !document.mozFullScreenElement && 
      !document.msFullscreenElement) {
    // Enter fullscreen
    if (canvas.requestFullscreen) {
      canvas.requestFullscreen().catch(err => {
        console.log('Error attempting to enable fullscreen:', err);
        alert('Failed to enter fullscreen mode');
      });
    } else if (canvas.webkitRequestFullscreen) {
      canvas.webkitRequestFullscreen();
    } else if (canvas.mozRequestFullScreen) {
      canvas.mozRequestFullScreen();
    } else if (canvas.msRequestFullscreen) {
      canvas.msRequestFullscreen();
    }
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
}

// Event listeners for controls
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('refreshBtn').addEventListener('click', refreshData);
  document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
  document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
  document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
  document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
  
  // Mouse controls for panning
  const canvas = document.getElementById('boardCanvas');
  
  canvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      panX += deltaX;
      panY += deltaY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    }
  });
  
  canvas.addEventListener('mouseup', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });
  
  canvas.addEventListener('mouseleave', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });
  
  // Wheel zoom
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.5, Math.min(3, zoomLevel * zoomFactor));
    
    if (newZoom !== zoomLevel) {
      const scaleChange = newZoom / zoomLevel;
      panX = mouseX - (mouseX - panX) * scaleChange;
      panY = mouseY - (mouseY - panY) * scaleChange;
      zoomLevel = newZoom;
    }
  });
  
  canvas.style.cursor = 'grab';
});

  // Wait for both images to load before animating
  let imagesLoaded = 0;
  function checkLoaded() {
    imagesLoaded++;
    if (imagesLoaded === 2) {
      requestAnimationFrame(animateSprite);
    }
  }
  deskImg.onload = checkLoaded;
  spriteSheet.onload = checkLoaded;

  // Add click event listener to canvas for user info
  canvas.addEventListener('click', function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / zoomLevel;
    const y = (e.clientY - rect.top - panY) / zoomLevel;
    
    // Check if click is on a user
    const clickedUser = findUserAtPosition(x, y);
    if (clickedUser) {
      showUserInfo(clickedUser);
    }
  });

  function findUserAtPosition(x, y) {
    return boardUsers.find(user => {
      if (!user.desk) return false;
      
      let deskCoord = user.desk;
      if (typeof deskCoord === "string") {
        const [x, y] = deskCoord.split(',').map(Number);
        deskCoord = {x, y};
      }
      
      const px = deskCoord.x * cellSize;
      const py = deskCoord.y * cellSize;
      
      // Check if click is within the desk area (including avatar and name tag)
      return x >= px && x <= px + cellSize && y >= py && y <= py + cellSize;
    });
  }

  async function showUserInfo(user) {
    const modal = document.getElementById('userInfoModal');
    const title = document.getElementById('userInfoTitle');
    const details = document.getElementById('userInfoDetails');
    
    title.textContent = `${user.username}'s Information`;
    
    try {
      // Fetch user's detailed information including clock times
      console.log('Fetching user data from:', `${window.ApiUrlLink}/user/${user.username}`);
      const response = await fetch(`${window.ApiUrlLink}/user/${user.username}`);
      console.log('User response status:', response.status);
      console.log('User response ok:', response.ok);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const userData = await response.json();
      console.log('User data received:', userData);
      
      // Also fetch current hours data which might contain clock times
      let hoursData = null;
      try {
        console.log('Fetching hours data from:', `${window.ApiUrlLink}/current_hours`);
        const hoursResponse = await fetch(`${window.ApiUrlLink}/current_hours`);
        console.log('Hours response status:', hoursResponse.status);
        
        if (hoursResponse.ok) {
          const hoursResponseData = await hoursResponse.json();
          console.log('All hours data:', hoursResponseData);
          hoursData = hoursResponseData.find(u => u.username === user.username);
          console.log('Hours data for user:', user.username, hoursData);
        } else {
          console.log('Hours response not ok:', hoursResponse.status);
        }
      } catch (e) {
        console.log('Could not fetch hours data:', e);
      }
      
      console.log('User data from /user endpoint:', userData);
      console.log('Full hoursData object:', hoursData);
      console.log('Available fields in userData:', Object.keys(userData));
      console.log('Available fields in hoursData:', hoursData ? Object.keys(hoursData) : 'No hours data');
      console.log('Clock in time field found:', userData.clock_in_time || userData.clockInTime || userData.clock_in);
      console.log('Clock out time field found:', userData.clock_out_time || userData.clockOutTime || userData.clock_out);
      console.log('User status:', userData.status);
      
      // Calculate working time if clocked in
      let workingTime = 'N/A';
      let clockInTime = 'N/A';
      let clockOutTime = 'N/A';
      
      const clockInTimeField = userData.clock_in_time || userData.clockInTime || userData.clock_in || 
                              (hoursData && hoursData.clock_in_time) || (hoursData && hoursData.clockInTime);
      const clockOutTimeField = userData.clock_out_time || userData.clockOutTime || userData.clock_out || 
                               (hoursData && hoursData.clock_out_time) || (hoursData && hoursData.clockOutTime);
      
      if (clockInTimeField) {
        try {
          console.log('Parsing clock in time:', clockInTimeField);
          const clockIn = new Date(clockInTimeField);
          console.log('Parsed clock in Date object:', clockIn);
          console.log('Clock in timestamp:', clockIn.getTime());
          console.log('Is NaN:', isNaN(clockIn.getTime()));
          
          if (!isNaN(clockIn.getTime())) {
            clockInTime = clockIn.toLocaleTimeString();
            console.log('Successfully parsed clock in time:', clockInTime);
            
            if (userData.status === 'clocked-out' && clockOutTimeField) {
              try {
                console.log('Parsing clock out time:', clockOutTimeField);
                const clockOut = new Date(clockOutTimeField);
                console.log('Parsed clock out Date object:', clockOut);
                console.log('Clock out timestamp:', clockOut.getTime());
                console.log('Is NaN:', isNaN(clockOut.getTime()));
                
                if (!isNaN(clockOut.getTime())) {
                  clockOutTime = clockOut.toLocaleTimeString();
                  const duration = clockOut - clockIn;
                  workingTime = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                               Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
                  console.log('Successfully calculated working time for clocked-out user:', workingTime);
                }
              } catch (e) {
                console.log('Error parsing clock out time:', e);
              }
            } else if (userData.status !== 'clocked-out') {
              const now = new Date();
              const duration = now - clockIn;
              workingTime = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                           Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
              console.log('Successfully calculated working time for active user:', workingTime);
            }
          } else {
            console.log('Invalid clock in time - NaN result');
          }
        } catch (e) {
          console.log('Error parsing clock in time:', e);
        }
      } else {
        console.log('No clock in time field found');
      }
      
      // Calculate break times
      let breakStartTime = 'N/A';
      let breakEndTime = 'N/A';
      let breakDuration = 'N/A';

      const breakStartTimeField = userData.break_start_time || (hoursData && hoursData.break_start_time);
      const breakEndTimeField = userData.break_end_time || (hoursData && hoursData.break_end_time);

      if (breakStartTimeField) {
        try {
          const breakStart = new Date(breakStartTimeField);
          if (!isNaN(breakStart.getTime())) {
            breakStartTime = breakStart.toLocaleTimeString();
            
            // If user is currently on break, calculate current break duration
            if (userData.status === 'break') {
              const now = new Date();
              const duration = now - breakStart;
              breakDuration = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                             Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
            } else if (breakEndTimeField) {
              // User finished break, calculate break duration from start to end
              try {
                const breakEnd = new Date(breakEndTimeField);
                if (!isNaN(breakEnd.getTime())) {
                  const duration = breakEnd - breakStart;
                  breakDuration = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                                 Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
                  breakEndTime = breakEnd.toLocaleTimeString();
                }
              } catch (e) {
                console.log('Error calculating break end time:', e);
              }
            }
          }
        } catch (e) {
          console.log('Error parsing break start time:', e);
        }
      }
      
      // Handle desk coordinates properly
      let deskDisplay = 'N/A';
      if (user.desk) {
        if (typeof user.desk === 'string') {
          deskDisplay = user.desk;
        } else if (user.desk.x !== undefined && user.desk.y !== undefined) {
          deskDisplay = `${user.desk.x}, ${user.desk.y}`;
        }
      }

      // Get work and break hours from the backend data
      const workHours = hoursData ? hoursData.work_hours : (userData.work_hours || 0);
      const breakHours = hoursData ? hoursData.break_hours : (userData.break_hours || 0);
      
      // Format hours for display
      const formatHours = (hours) => {
        if (hours === 0) return '0h 0m';
        const wholeHours = Math.floor(hours);
        const minutes = Math.round((hours - wholeHours) * 60);
        return `${wholeHours}h ${minutes}m`;
      };

      // Get job site location if available
      const jobSiteLocation = userData.job_site_location || 'N/A';
      
      // Create Google Maps link for job site location
      const createMapLink = (location) => {
        if (location && location !== 'N/A') {
          const encodedLocation = encodeURIComponent(location);
          return `https://www.google.com/maps/search/?api=1&query=${encodedLocation}`;
        }
        return null;
      };
      
      const mapLink = createMapLink(jobSiteLocation);
      
      // Calculate time in current status
      let timeInStatus = 'N/A';
      if (userData.status && userData.status !== 'clocked-out') {
        let statusStartTime = null;
        
        if (userData.status === 'clocked-in' && clockInTimeField) {
          statusStartTime = new Date(clockInTimeField);
        } else if (userData.status === 'break' && breakStartTimeField) {
          statusStartTime = new Date(breakStartTimeField);
        } else if (userData.status === 'work-from-home' && clockInTimeField) {
          statusStartTime = new Date(clockInTimeField);
        } else if (userData.status === 'job-site' && clockInTimeField) {
          statusStartTime = new Date(clockInTimeField);
        }
        
        if (statusStartTime && !isNaN(statusStartTime.getTime())) {
          const now = new Date();
          const duration = now - statusStartTime;
          const hours = Math.floor(duration / (1000 * 60 * 60));
          const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
          
          if (hours > 0) {
            timeInStatus = `${hours}h ${minutes}m`;
          } else {
            timeInStatus = `${minutes}m`;
          }
        }
      }

      details.innerHTML = `
        <div class="user-info-item">
          <span class="user-info-label">Status:</span>
          <span class="user-info-value">${userData.status || 'N/A'}</span>
        </div>
        
        <!-- ===== STATUS CHANGE SECTION ===== -->
        <div class="user-info-item" style="flex-direction: column; align-items: flex-start; gap: 6px; margin-bottom: 10px;">
          <span class="user-info-label">Change Status:</span>
          <div style="display: flex; gap: 10px; width: 100%;">
            <select id="statusChangeSelect" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
              <option value="clocked-in">Clocked In</option>
              <option value="break">On Break</option>
              <option value="work-from-home">Work from Home</option>
              <option value="job-site">Job Site</option>
              <option value="clocked-out">Clocked Out</option>
            </select>
            <button id="updateStatusBtn" style="padding: 8px 16px; background: #2d2e4b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Update</button>
          </div>
          <div id="statusUpdateMessage" style="font-size: 12px; color: #666; margin-top: 2px;"></div>
        </div>
        
        <div class="user-info-item">
          <span class="user-info-label">Time in Status:</span>
          <span class="user-info-value">${timeInStatus}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Desk:</span>
          <span class="user-info-value">${deskDisplay}</span>
        </div>
        ${userData.status === 'job-site' ? `
        <div class="user-info-item">
          <span class="user-info-label">Job Site Location:</span>
          <span class="user-info-value">
            ${mapLink ? 
              `<a href="${mapLink}" target="_blank" style="color: #007bff; text-decoration: underline; cursor: pointer;">${jobSiteLocation} üìç</a>` : 
              jobSiteLocation
            }
          </span>
        </div>
        ` : ''}
      `;
    } catch (error) {
      console.error('Error in showUserInfo:', error);
      details.innerHTML = `<p>Error loading user information: ${error.message}</p>`;
    }
    
      modal.style.display = 'flex';
      
      // ===== STATUS CHANGE FUNCTIONALITY =====
      // Set the current status as the selected option
      const statusSelect = document.getElementById('statusChangeSelect');
      if (statusSelect) {
        statusSelect.value = userData.status || 'clocked-out';
      }
      
      // Add event listener for status update button
      const updateBtn = document.getElementById('updateStatusBtn');
      if (updateBtn) {
        updateBtn.onclick = function() {
          updateUserStatus(user.username, statusSelect.value);
        };
      }
    }
    
    // ===== STATUS UPDATE FUNCTION =====
    // Function to update a user's status via API
    async function updateUserStatus(username, newStatus) {
      const updateBtn = document.getElementById('updateStatusBtn');
      const messageDiv = document.getElementById('statusUpdateMessage');
      
      if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
      }
      
      if (messageDiv) {
        messageDiv.textContent = 'Updating status...';
        messageDiv.style.color = '#666';
      }
      
      try {
        // Call the API to update the user's status
        const response = await fetch(`${window.ApiUrlLink}/status/${username}/${newStatus}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });
        
        if (response.ok) {
          // Success - update the message and refresh the board
          if (messageDiv) {
            messageDiv.textContent = 'Status updated successfully!';
            messageDiv.style.color = '#28a745';
          }
          
          // Refresh the board data to show the updated status
          setTimeout(() => {
            refreshData();
            // Close the modal after a short delay
            setTimeout(() => {
              document.getElementById('userInfoModal').style.display = 'none';
            }, 1000);
          }, 500);
        } else {
          // Error - show error message
          if (messageDiv) {
            messageDiv.textContent = 'Failed to update status. Please try again.';
            messageDiv.style.color = '#dc3545';
          }
        }
      } catch (error) {
        console.error('Error updating user status:', error);
        if (messageDiv) {
          messageDiv.textContent = 'Error updating status. Please try again.';
          messageDiv.style.color = '#dc3545';
        }
      } finally {
        // Re-enable the button
        if (updateBtn) {
          updateBtn.disabled = false;
          updateBtn.textContent = 'Update';
        }
      }
    }

    // ===== MODAL CLOSE FUNCTIONALITY =====
    // Close user info modal
    document.getElementById('closeUserInfo').onclick = function() {
      document.getElementById('userInfoModal').style.display = 'none';
    };
  
  // Close modal when clicking outside
  document.getElementById('userInfoModal').onclick = function(e) {
    if (e.target === this) {
      this.style.display = 'none';
    }
  };

  // Basic canvas controls
  document.getElementById('refreshBtn').onclick = function() {
    location.reload();
  };

  document.getElementById('zoomInBtn').onclick = function() {
    // TODO: Implement zoom in functionality
    console.log('Zoom in clicked');
  };

  document.getElementById('zoomOutBtn').onclick = function() {
    // TODO: Implement zoom out functionality
    console.log('Zoom out clicked');
  };

  document.getElementById('resetZoomBtn').onclick = function() {
    // TODO: Implement reset zoom functionality
    console.log('Reset zoom clicked');
  };

  document.getElementById('fullscreenBtn').onclick = function() {
    const canvas = document.getElementById('boardCanvas');
    if (canvas.requestFullscreen) {
      canvas.requestFullscreen();
    } else if (canvas.webkitRequestFullscreen) {
      canvas.webkitRequestFullscreen();
    } else if (canvas.mozRequestFullScreen) {
      canvas.mozRequestFullScreen();
    } else if (canvas.msRequestFullscreen) {
      canvas.msRequestFullscreen();
    }
  };
}); // Close the first DOMContentLoaded event listener
  </script>
</body>
</html>
