<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Office Board</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="config.js" defer></script>
  <script defer>
    document.addEventListener("DOMContentLoaded", () => {
      const base = document.createElement('base');
      base.href = location.hostname === 'localhost' ? '/' : 'https://joshthinh.github.io/Elen-Signin/';
      document.head.appendChild(base);
  
      // Ensure config.js is loaded before accessing API_URL / API_URL_DEPLOYED
      if (typeof API_URL === 'undefined' || typeof API_URL_DEPLOYED === 'undefined') {
        console.error('API_URL or API_URL_DEPLOYED is not defined. Check config.js loading.');
        return;
      }
  
      window.ApiUrlLink = location.hostname === 'localhost' ? API_URL : API_URL_DEPLOYED;
  
      // Continue rest of logic here if needed
    });
  </script>
  <style>
    /* Responsive scaling variables */
    :root {
      --scale-phone: 0.8;
      --scale-tablet: 0.9;
      --scale-desktop: 1;
      --scale-tv: 1.1;
    }
    
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 16px;
      color: white;
      background: #2d2e4bf2;
      padding-left: 100px; /* Prevent content from being hidden under sidebar */
      position: relative;
    }
    
    /* Left Sidebar Styles */
    .left-sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100px;
      height: 100vh;
      background: #4a4c6b;
      color: #fff;
      z-index: 1001;
      transition: width 0.3s ease;
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
    }
    
    .left-sidebar.expanded {
      width: 200px;
    }
    
    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 50px 15px;
      cursor: pointer;
      height: 50px;
    }
    
    .sidebar-header h3 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s ease;
      position: absolute;
      left: 20px;
    }
    
    .left-sidebar.expanded .sidebar-header h3 {
      opacity: 1;
    }
    
    .sidebar-toggle {
      font-size: 2.5rem;
      cursor: pointer !important;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      transition: transform 0.3s ease;
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      background: transparent;
      border: none;
      outline: none;
      margin: 0 auto;
      position: relative;
      top: 5px;
    }
    
    .left-sidebar.expanded .sidebar-toggle {
      height: 60px;
    }
    
    .left-sidebar.expanded .sidebar-toggle {
      transform: rotate(90deg);
    }
    
    .sidebar-close {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 1.5rem;
      cursor: pointer;
      color: #fff;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 10;
      background: none;
      border: none;
      padding: 5px;
      border-radius: 4px;
    }
    
    .left-sidebar.expanded .sidebar-close {
      opacity: 1;
    }
    
    .sidebar-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    /* Hide only the toggle button when sidebar is expanded, keep the header and menu text */
    .left-sidebar.expanded .sidebar-toggle {
      display: none;
    }
    
    .sidebar-icons {
      padding: 10px 0;
    }
    
    .sidebar-icon-item {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 50px;
      color: #fff;
      text-decoration: none;
      transition: all 0.3s ease;
      border-left: 3px solid transparent;
    }
    
    .sidebar-icon-item:hover {
      background: rgba(255, 255, 255, 0.1);
      border-left-color: #fff;
    }
    
    .sidebar-icon-item .icon {
      font-size: 1.3rem;
      filter: grayscale(60%);
    }
    
    .sidebar-text {
      padding: 20px 0;
    }
    
    .sidebar-text a {
      display: block;
      padding: 15px 20px;
      color: #fff;
      text-decoration: none;
      font-size: 0.95rem;
      transition: all 0.3s ease;
      border-left: 3px solid transparent;
    }
    
    .sidebar-text a:hover {
      background: rgba(255, 255, 255, 0.1);
      border-left-color: #fff;
    }
    
    .board-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    
    .board-title {
      margin-bottom: 20px;
      color: white;
      font-size: 2rem;
      font-weight: bold;
      text-align: center;
      width: 100%;
    }
    
    /* Board Header and Stats */
    .board-header {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 20px;
      position: relative;
      width: 100%;
    }
    
    .board-stats {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .stat-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 15px;
      border-radius: 8px;
      text-align: center;
      min-width: 80px;
    }
    
    .stat-label {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-bottom: 5px;
      display: block;
    }
    
    .stat-value {
      font-size: 1.2rem;
      font-weight: bold;
    }
    
    /* Status Legend Styles */
    .status-legend {
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
      min-width: 200px;
    }
    
    .status-legend h3 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 1.1rem;
      font-weight: 600;
    }
    
    .legend-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
      color: #555;
    }
    
    .status-circle {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .status-circle.clocked-in {
      background-color: #28a745; /* Green */
    }
    
    .status-circle.break {
      background-color: #ffc107; /* Yellow */
    }
    
    .status-circle.work-from-home {
      background-color: #17a2b8; /* Blue */
    }
    
    .status-circle.job-site {
      background-color: #8B4513; /* Brown */
    }
    
    .status-circle.clocked-out {
      background-color: #dc3545; /* Red */
    }
    
    /* Canvas Container */
    .canvas-container {
      position: relative;
      overflow: hidden;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      z-index: 200;
    }
    
    /* Fullscreen styles */
    #boardCanvas:fullscreen {
      width: 100vw;
      height: 100vh;
      margin: 0;
      border: none;
      border-radius: 0;
      box-shadow: none;
    }
    
    #boardCanvas:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      margin: 0;
      border: none;
      border-radius: 0;
      box-shadow: none;
    }
    
    #boardCanvas:-moz-full-screen {
      width: 100vw;
      height: 100vh;
      margin: 0;
      border: none;
      border-radius: 0;
      box-shadow: none;
    }
    
    #boardCanvas:-ms-fullscreen {
      width: 100vw;
      height: 100vh;
      margin: 0;
      border: none;
      border-radius: 0;
      box-shadow: none;
    }
    
    /* Center Stats */
    .center-stats {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }
    
    .center-stat {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      box-shadow: 0 4px 16px rgba(40, 167, 69, 0.3);
      transform: scale(1.1);
    }
    
    .center-stat .stat-label,
    .center-stat .stat-value {
      color: white;
    }
    
    /* Board Controls */
    .board-controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .control-btn {
      background: #2d2e4b;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    .control-btn:hover {
      background: #1a1b2e;
    }

    /* User Info Modal Styles */
    .user-info-modal {
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
    }
    
    .user-info-content {
      background: white;
      padding: 30px;
      border-radius: 16px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    
    .user-info-content h3 {
      margin-top: 0;
      color: #333;
      font-size: 1.5rem;
      margin-bottom: 20px;
    }
    
    .user-info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    
    .user-info-label {
      font-weight: bold;
      color: #2d2e4b;
    }
    
    .user-info-value {
      color: #6c757d;
    }

    .confirm-btn {
      background-color: #2d2e4b;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .confirm-btn:hover {
      background-color: #1a1b2e;
    }
    
    /* iPhone and small phones (up to 428px) */
    @media screen and (max-width: 428px) {
      :root {
        --scale-phone: 0.75;
        --scale-tablet: 0.8;
        --scale-desktop: 0.85;
        --scale-tv: 0.9;
      }
      
      body {
        font-size: calc(14px * var(--scale-phone));
        padding-left: calc(100px * var(--scale-phone)) !important;
        padding-top: 0 !important;
      }
      
      .board-container {
        padding: calc(10px * var(--scale-phone)) !important;
        margin: calc(10px * var(--scale-phone)) !important;
        max-width: calc(100vw - 20px) !important;
        width: calc(100vw - 20px) !important;
        overflow-x: hidden !important;
        box-sizing: border-box !important;
      }
      
      .board-title {
        font-size: calc(1.5rem * var(--scale-phone));
        margin-bottom: calc(15px * var(--scale-phone));
      }
      
      .board-header {
        flex-direction: column;
        align-items: center;
        margin-bottom: calc(15px * var(--scale-phone));
        gap: calc(10px * var(--scale-phone));
      }
      
      .status-legend {
        order: 1;
        align-self: flex-start;
        margin-bottom: calc(10px * var(--scale-phone));
      }
      
      .board-title {
        order: 2;
      }
      
      .board-stats {
        order: 3;
      }
      
      .board-stats {
        gap: calc(8px * var(--scale-phone));
        justify-content: center;
        width: 100%;
        flex-wrap: wrap;
      }
      
      .stat-item {
        min-width: calc(70px * var(--scale-phone));
        padding: calc(6px * var(--scale-phone)) calc(8px * var(--scale-phone));
      }
      
      .stat-label {
        font-size: calc(0.7rem * var(--scale-phone));
        margin-bottom: calc(2px * var(--scale-phone));
      }
      
      .stat-value {
        font-size: calc(1rem * var(--scale-phone));
      }
      
      .canvas-container {
        border-radius: calc(12px * var(--scale-phone));
        box-shadow: 0 calc(2px * var(--scale-phone)) calc(12px * var(--scale-phone)) rgba(0,0,0,0.08);
        overflow: hidden;
        max-width: calc(100vw - 20px);
        width: calc(100vw - 20px);
        position: relative;
        z-index: 200;
      }
      
      #boardCanvas {
        width: calc(100vw - 20px) !important;
        height: auto !important;
        max-height: calc(60vh * var(--scale-phone));
        margin: calc(10px * var(--scale-phone)) auto !important;
        border-width: calc(2px * var(--scale-phone)) !important;
        border-radius: calc(12px * var(--scale-phone)) !important;
      }
      
      .board-controls {
        gap: calc(6px * var(--scale-phone));
        margin-top: calc(15px * var(--scale-phone));
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .control-btn {
        padding: calc(8px * var(--scale-phone)) calc(12px * var(--scale-phone));
        font-size: calc(12px * var(--scale-phone));
        border-radius: calc(4px * var(--scale-phone));
      }
      
      /* Status Legend Mobile Scaling */
      .status-legend {
        padding: calc(10px * var(--scale-phone));
        min-width: calc(150px * var(--scale-phone));
        position: absolute;
        left: calc(10px * var(--scale-phone));
        top: calc(-80px * var(--scale-phone));
        transform: scale(var(--scale-phone));
        transform-origin: top left;
      }
      
      .status-legend h3 {
        font-size: calc(0.9rem * var(--scale-phone));
        margin-bottom: calc(8px * var(--scale-phone));
      }
      
      .legend-items {
        gap: calc(6px * var(--scale-phone));
      }
      
      .legend-item {
        gap: calc(6px * var(--scale-phone));
        font-size: calc(0.75rem * var(--scale-phone));
      }
      
      .status-circle {
        width: calc(10px * var(--scale-phone));
        height: calc(10px * var(--scale-phone));
      }
      
      .left-sidebar {
        width: calc(100px * var(--scale-phone));
        height: 100vh;
        min-height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      
      .sidebar-toggle {
        font-size: calc(2rem * var(--scale-phone));
        width: calc(60px * var(--scale-phone));
        height: calc(60px * var(--scale-phone));
      }
    }
  </style>
</head>
<body>
  <div class="left-sidebar" id="leftSidebar">
    <div class="sidebar-header" onclick="toggleSidebar()">
      <h3>Menu</h3>
      <div class="sidebar-toggle" id="sidebarToggle">&#9776;</div>
    </div>
    <button class="sidebar-close" id="sidebarClose" onclick="toggleSidebar()">‚úï</button>
    
    <!-- Icon Mode -->
    <div class="sidebar-icons" id="sidebarIcons">
      <a href="#" class="sidebar-icon-item" id="dashboardIcon" title="Dashboard">
        <span class="icon">üìä</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="boardIcon" title="Board">
        <span class="icon">üìã</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="settingsIcon" title="Settings">
        <span class="icon">‚öôÔ∏è</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="submitIcon" title="Submit Email">
        <span class="icon">üìß</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="viewEmailIcon" title="View Email">
        <span class="icon">üì¨</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="hoursIcon" title="Hours">
        <span class="icon">‚è±Ô∏è</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="editUsersIcon" title="Edit Users">
        <span class="icon">üë•</span>
      </a>
      <a href="#" class="sidebar-icon-item" id="signOutIcon" title="Sign Out">
        <span class="icon">üö™</span>
      </a>
    </div>
    
    <!-- Text Mode -->
    <div class="sidebar-text" id="sidebarText" style="display: none;">
      <a href="dashboard.html" id="dashboardLink">Dashboard</a>
      <a href="board.html" id="boardLink">Board</a>
      <a href="settings.html" id="settingsLink">Settings</a>
      <a href="submit_email.html" id="submitLink">Submit Email</a>
      <a href="view_email.html" id="viewEmailLink">View Email</a>
      <a href="hours.html" id="hourLink">Hours</a>
      <a href="users.html" id="editUsersLink">Edit Users</a>
      <a href="index.html" id="signOutLink">Sign Out</a>
    </div>
  </div>
  
  <div class="board-container">
    <h1 class="board-title">Office Presence Board</h1>
    <div class="board-header">
      <div class="status-legend">
        <h3>Status Legend</h3>
        <div class="legend-items">
          <div class="legend-item">
            <div class="status-circle clocked-in"></div>
            <span>Clocked In</span>
          </div>
          <div class="legend-item">
            <div class="status-circle break"></div>
            <span>On Break</span>
          </div>
          <div class="legend-item">
            <div class="status-circle work-from-home"></div>
            <span>Work from Home</span>
          </div>
          <div class="legend-item">
            <div class="status-circle job-site"></div>
            <span>Job Site</span>
          </div>
          <div class="legend-item">
            <div class="status-circle clocked-out"></div>
            <span>Clocked Out</span>
          </div>
        </div>
      </div>
      <div class="board-stats">
        <div class="stat-item">
          <span class="stat-label">Total Active:</span>
          <span class="stat-value" id="totalActive">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Clocked In:</span>
          <span class="stat-value" id="clockedInCount">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">On Break:</span>
          <span class="stat-value" id="breakCount">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Last Updated:</span>
          <span class="stat-value" id="lastUpdated">--</span>
        </div>
      </div>
    </div>
    
    <div class="canvas-container">
      <canvas id="boardCanvas" width="1100" height="700" style="display:block; margin: 40px auto; background: transparent; border: 3px solid #333333; border-radius: 16px; box-shadow: 0 4px 24px rgba(0,0,0,0.08); cursor: grab;"></canvas>
    </div>
    
    <div class="board-controls">
      <button id="refreshBtn" class="control-btn">üîÑ Refresh</button>
      <button id="zoomInBtn" class="control-btn">üîç+</button>
      <button id="zoomOutBtn" class="control-btn">üîç-</button>
      <button id="resetZoomBtn" class="control-btn">üîç Reset</button>
      <button id="fullscreenBtn" class="control-btn">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <!-- User Info Modal -->
  <div id="userInfoModal" class="user-info-modal">
    <div class="user-info-content">
      <h3 id="userInfoTitle">User Information</h3>
      <div id="userInfoDetails">
        <!-- User info will be populated here -->
      </div>
      <button id="closeUserInfo" class="confirm-btn" style="margin-top: 20px;">Close</button>
    </div>
  </div>

  <script defer>
// --- Sidebar functions ---
function toggleSidebar() {
  console.log('Sidebar toggle clicked!');
  const sidebar = document.getElementById('leftSidebar');
  const icons = document.getElementById('sidebarIcons');
  const text = document.getElementById('sidebarText');
  
  if (sidebar.classList.contains('expanded')) {
    // Close the sidebar
    sidebar.classList.remove('expanded');
    icons.style.display = 'block';
    text.style.display = 'none';
    document.body.style.paddingLeft = '100px';
    console.log('Sidebar closed');
  } else {
    // Open the sidebar
    sidebar.classList.add('expanded');
    icons.style.display = 'none';
    text.style.display = 'block';
    document.body.style.paddingLeft = '200px';
    console.log('Sidebar opened');
  }
}

document.addEventListener('DOMContentLoaded', function() {
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebarHeader = document.querySelector('.sidebar-header');
  
  if (sidebarToggle) {
    sidebarToggle.addEventListener('click', function(e) {
      e.stopPropagation();
      toggleSidebar();
    });
  }
  
  if (sidebarHeader) {
    sidebarHeader.addEventListener('click', function(e) {
      e.stopPropagation();
      toggleSidebar();
    });
  }
});

document.getElementById('signOutLink').onclick = function(e) {
  e.preventDefault();
  localStorage.removeItem("user");
  window.location.href = "index.html";
};

document.addEventListener("DOMContentLoaded", () => {
  function getQueryParam(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
  }
  const username = getQueryParam('username');
  
  // Set up sidebar icon links
  if (username) {
    setupSidebarIconLinks(username);
    
    // Fetch user info to determine admin status
    fetch(`${ApiUrlLink}/user/${username}`)
      .then(res => res.json())
      .then(user => {
        if (user && user.role === 'admin') {
          document.getElementById('hourLink').style.display = 'block';
          document.getElementById('hoursIcon').style.display = 'flex';
        } else {
          document.getElementById('hourLink').style.display = 'none';
          document.getElementById('hoursIcon').style.display = 'none';
        }
        // Edit Users link is now visible to everyone
      });
  }
});

function setupSidebarIconLinks(username) {
  // Set href attributes for sidebar icons
  document.getElementById('dashboardIcon').href = `dashboard.html?username=${encodeURIComponent(username)}`;
  document.getElementById('boardIcon').href = `board.html?username=${encodeURIComponent(username)}`;
  document.getElementById('settingsIcon').href = `settings.html?username=${encodeURIComponent(username)}`;
  document.getElementById('submitIcon').href = `submit_email.html?username=${encodeURIComponent(username)}`;
  document.getElementById('viewEmailIcon').href = `view_email.html?username=${encodeURIComponent(username)}`;
  document.getElementById('hoursIcon').href = `hours.html?username=${encodeURIComponent(username)}`;
  document.getElementById('editUsersIcon').href = `users.html?username=${encodeURIComponent(username)}`;
  
  // Set up sign out functionality for the icon
  document.getElementById('signOutIcon').onclick = function(e) {
    e.preventDefault();
    localStorage.removeItem('user');
    window.location.href = 'index.html';
  };
  
  // Hide board navigation since we're already on the board page
  document.getElementById('boardIcon').style.display = 'none';
  document.getElementById('boardLink').style.display = 'none';
}

// --- End Sidebar logic ---

document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('boardCanvas');
  const ctx = canvas.getContext('2d');

  // Load images
  const deskImg = new Image();
  deskImg.src = `${document.baseURI}Static/Images/Desks/desk.png`;
  
  const deskOpImg = new Image();
  deskOpImg.src = `${document.baseURI}Static/Images/Desks/deskop.png`;

  // Wait for images to load
  Promise.all([deskImg.decode(), deskOpImg.decode()]).then(() => {
    // Clear canvas with transparent background
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Load newbackground.png as layout guide and store it globally
    const layoutImg = new Image();
    layoutImg.onload = function() {
      // Store the image globally so it can be used in drawOfficeWithUsers
      window.layoutBackgroundImage = layoutImg;
      
      // Draw grid on canvas
      drawGrid();
      
      // Note: Background image will be drawn by the existing drawOfficeWithUsers function
      // so we don't need to draw it here to avoid duplication
      
      console.log('New desk layout canvas ready for development - newbackground.png loaded and ready for use');
    };
    layoutImg.src = `${document.baseURI}Static/Images/Background/newbackground.png`;
    
    // Function to draw grid on canvas
    function drawGrid() {
      const gridSize = 64; // Grid cell size in pixels (matches desk positions)
      const gridColor = 'rgba(255, 255, 255, 0.3)'; // Light white with transparency
      const gridLineWidth = 1;
      
      ctx.save();
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = gridLineWidth;
      
      // Draw vertical lines
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    

  }).catch(error => {
    console.error('Error loading images:', error);
  });

  // --- Drawing Logic ---
  // Global users array for animation
  let boardUsers = [];

  // Global variables for zoom and pan
  let zoomLevel = 1;
  let panX = 0;
  let panY = 0;
  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;

  // Animation variables
  let frameIndex = 0;
  let lastFrameTime = 0;
  const frameDuration = 200; // ms per frame

  // Character sprite config
  const spriteSheet = new Image();
  spriteSheet.src = `${document.baseURI}Static/Images/Characters/Boy_idle.png`;
  const frameWidth = 48;
  const frameHeight = 48;
  const totalFrames = 4;

  // Constants
  const gridCols = 22; // number of columns in your grid (positions 0-21)
  const gridRows = 8; // number of rows in your grid (reduced to match your layout)
  const cellSize = 64; // pixels per grid cell

  // Desk positions from the provided text grid (x = column, y = row, 0-indexed)
  // Desk positions from new_desklayout.html with rotation support
  const deskPositions = [
    // Buddies Row 0: xoxox
    {x:2.7, y:1, rotation: 90, deskType: 'deskop'}, {x:5, y:1.3, rotation: 0},
    // Row 1: oxxx
    {x:0.9, y:2.5, rotation: 0, deskType: 'deskop'},
    // Row 2: oxxoxxxo
    {x:0.9, y:3.7, rotation: 0}, {x:4.2, y:3.4, rotation: 0, deskType: 'deskop'}, {x:8, y:4, rotation: 0},
    // Row 3: xxxxxxxxxxoxxoxxo
    {x:2.1, y:7.7, rotation: -45}, {x:2.6, y:8.2, rotation: -45}, 

    {x:5.1, y:8.4, rotation: 0, deskType: 'deskop'}, {x:5.1, y:9.1, rotation: 0, deskType: 'deskop'}, {x:4.3, y:9.1, rotation: 0}, {x:4.3, y:8.4, rotation: 0},  
    
    {x:7.5, y:8.2, rotation: 0, deskType: 'deskop'}, {x:7.5, y:8.9, rotation: 0, deskType: 'deskop'}, {x:6.7, y:8.2, rotation: 0}, {x:6.7, y:8.9, rotation: 0},

    {x:10.1, y:8.4, rotation: 0, deskType: 'deskop'}, {x:10.1, y:9.1, rotation: 0, deskType: 'deskop'}, {x:9.3, y:9.1, rotation: 0}, {x:9.3, y:8.4, rotation: 0},

    {x:12.2, y:8.5, rotation: 0, deskType: 'deskop'}, {x:12.2, y:9.2, rotation: 0, deskType: 'deskop'}, {x:11.4, y:8.5, rotation: 0}, {x:11.4, y:9.2, rotation: 0},
    
    {x:14.35, y:8.2, rotation: 0, deskType: 'deskop'}, {x:14.35, y:8.9, rotation: 0, deskType: 'deskop'}, {x:13.6, y:8.2, rotation: 0}, {x:13.6, y:8.9, rotation: 0},

    {x:15.5, y:7.6, rotation: 0}, {x:15.5, y:9.3, rotation: 0},
    // Row 4: oxxxx
    {x:0, y:5, rotation: 0},
  ];

// Function to update statistics
function updateStats(users) {
  const activeUsers = users.filter(user => 
    user.desk && (user.status === "clocked-in" || user.status === "break")
  );
  const clockedInUsers = users.filter(user => 
    user.desk && user.status === "clocked-in"
  );
  const breakUsers = users.filter(user => 
    user.desk && user.status === "break"
  );
  
  document.getElementById('totalActive').textContent = activeUsers.length;
  document.getElementById('clockedInCount').textContent = clockedInUsers.length;
  document.getElementById('breakCount').textContent = breakUsers.length;
  document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
}

// Function to refresh data
function refreshData() {
  fetch(`${ApiUrlLink}/users`)
    .then(res => res.json())
    .then(data => {
      boardUsers = data.users;
      updateStats(boardUsers);
      requestAnimationFrame(animateSprite);
    })
    .catch(error => {
      console.error('Error fetching users:', error);
    });
}

// Fetch users and update boardUsers, then start animation
refreshData();

// Auto-refresh every 30 seconds
setInterval(refreshData, 30000);

// Avatar animation configs
const avatarConfigs = {
  "City_men_idle.png": {
    frameWidth: 128,
    frameHeight: 128,
    totalFrames: 6,
    frameDuration: 250, // slower
    frameSequence: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] // loop
  },
  "Boy_idle.png": {
    frameWidth: 48,
    frameHeight: 48,
    totalFrames: 4,
    frameDuration: 200
  }
};
const AVATAR_BOX_SIZE = 64;

// Avatar sprite cache
const avatarSpriteSheets = {};

function getAvatarSpriteSheet(file) {
  if (!avatarSpriteSheets[file]) {
    const img = new window.Image();
    img.src = `${document.baseURI}Static/Images/Characters/${file}`;
    avatarSpriteSheets[file] = img;
  }
  return avatarSpriteSheets[file];
}

// Per-user animation state
const userAnimStates = {};



function drawOfficeWithUsers(users) {
  // Apply zoom and pan transformations
  applyZoomAndPan();
  
  // Clear canvas with transparent background
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw newbackground.png as layout guide (same as new_desklayout.html)
  if (window.layoutBackgroundImage && window.layoutBackgroundImage.complete) {
    ctx.save();
    
    // Move to the center of the canvas for rotation
    ctx.translate(canvas.width / 2, canvas.height / 2);
    
    // Rotate 90 degrees to the left (counterclockwise)
    ctx.rotate(-Math.PI / 2);
    
    // Calculate scale to fit the rotated image and make it smaller
    const baseScale = Math.min(canvas.width / window.layoutBackgroundImage.height, canvas.height / window.layoutBackgroundImage.width);
    const scale = baseScale * 1.2; // Make it 20% bigger (smaller than before)
    const scaledWidth = window.layoutBackgroundImage.width * scale;
    const scaledHeight = window.layoutBackgroundImage.height * scale;
    
    // Draw the rotated image centered
    ctx.drawImage(window.layoutBackgroundImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
    
    // Restore the canvas context
    ctx.restore();
  }
  
  // Draw grid (optional, for visual reference)
  ctx.save();
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Light white with transparency
  for (let r = 0; r <= gridRows; r++) {
    ctx.beginPath();
    ctx.moveTo(0, r * cellSize);
    ctx.lineTo(canvas.width, r * cellSize);
    ctx.stroke();
  }
  for (let c = 0; c <= gridCols; c++) {
    ctx.beginPath();
    ctx.moveTo(c * cellSize, 0);
    ctx.lineTo(c * cellSize, canvas.height);
    ctx.stroke();
  }
  ctx.restore();

  // Draw desks with sizing and rotation from new_desklayout.html
  deskPositions.forEach((desk, index) => {
    const px = desk.x * cellSize;
    const py = desk.y * cellSize;
    
    // Scale desk images smaller (75% of original size) - same as new_desklayout.html
    const deskSize = cellSize * 0.75; // 48px instead of 64px
    const offsetX = (cellSize - deskSize) / 2; // Center the smaller desk in the cell
    const offsetY = (cellSize - deskSize) / 2;
    
    ctx.save();
    
    // Move to desk center for rotation (if rotation is specified)
    if (desk.rotation !== undefined && desk.rotation !== 0) {
      ctx.translate(px + cellSize/2, py + cellSize/2);
      ctx.rotate(desk.rotation * Math.PI / 180);
      
      // Choose desk image based on deskType (if specified) or fall back to old logic
      const deskImage = desk.deskType === 'deskop' ? deskOpImg : 
                       (desk.deskType === 'desk' ? deskImg : 
                       (desk.x === 2 || desk.x === 6 || desk.x === 10 || desk.x === 14 || desk.x === 18 || desk.x === 21 ? deskImg : deskOpImg));
      
      // Draw desk image centered at origin
      ctx.drawImage(deskImage, -deskSize/2, -deskSize/2, deskSize, deskSize);
    } else {
      // No rotation - use old logic for desk type
      const useRegularDesk = [2, 6, 10, 14, 18, 21].includes(desk.x);
      const deskImage = useRegularDesk ? deskImg : deskOpImg;
      
      // Draw desk image with offset to center it
      ctx.drawImage(
        deskImage,
        px + offsetX, py + offsetY,
        deskSize, deskSize
      );
    }
    
    ctx.restore();
    
    // Add desk number for easy identification (same as new_desklayout.html)
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText((index + 1).toString(), px + cellSize/2, py + cellSize/2 + 5);
    ctx.restore();
  });

  // Draw users at their desks
  users.forEach(user => {
    if (!user.avatar) return;
    console.log(`User ${user.username}: status = ${user.status}, desk = ${user.desk}`);
    if (user.desk) {
      let deskCoord = user.desk;
      if (typeof deskCoord === "string") {
        const [x, y] = deskCoord.split(',').map(Number);
        deskCoord = {x, y};
      }
      const px = deskCoord.x * cellSize;
      const py = deskCoord.y * cellSize;
      const config = avatarConfigs[user.avatar] || avatarConfigs[Object.keys(avatarConfigs)[0]];
      const sequence = config.frameSequence || [...Array(config.totalFrames).keys()];
      const seqLen = sequence.length;
      const spriteSheet = getAvatarSpriteSheet(user.avatar);
      // Per-user animation state
      if (!userAnimStates[user.username]) {
        userAnimStates[user.username] = { frameIndex: 0, lastFrameTime: 0, seqIndex: 0 };
      }
      const state = userAnimStates[user.username];
      const now = performance.now();
      if (!state.lastFrameTime) state.lastFrameTime = now;
      const elapsed = now - state.lastFrameTime;
      if (elapsed > config.frameDuration) {
        state.seqIndex = (state.seqIndex + 1) % seqLen;
        state.lastFrameTime = now;
      }
      const frameToDraw = sequence[state.seqIndex];
      // Scale and center in 64x64 box
      const scale = Math.min(
        AVATAR_BOX_SIZE / config.frameWidth,
        AVATAR_BOX_SIZE / config.frameHeight
      );
      const drawWidth = config.frameWidth * scale;
      const drawHeight = config.frameHeight * scale;
      const offsetX = px + (cellSize - AVATAR_BOX_SIZE) / 2 + (AVATAR_BOX_SIZE - drawWidth) / 2;
      const offsetY = py + (cellSize - AVATAR_BOX_SIZE) / 2 + (AVATAR_BOX_SIZE - drawHeight) / 2;
      // Check if user is at a desk that uses desk.png (regular desk)
      const useRegularDesk = [2, 6, 10, 14, 18, 21].includes(deskCoord.x);
      
      // Adjust avatar positioning and direction based on desk type
      let avatarOffsetX = 6; // default pixels left (moved back to the right)
      let avatarOffsetY = -16; // pixels up (moved higher)
      
      // Draw house icon behind avatar and name for users working from home
      if (user.status === "work-from-home") {
        ctx.save();
        ctx.font = '60px Arial'; // Even bigger house icon
        ctx.fillStyle = '#17a2b8'; // Solid teal color
        ctx.textAlign = 'center';
        // Position house icon at the center of the desk, behind everything
        ctx.fillText('üè°', px + cellSize/2, py + cellSize/2 + 10);
        ctx.restore();
      }
      
      ctx.save();
      
      // Handle different statuses
      if (user.status === "break") {
        ctx.globalAlpha = 0.3; // faded
      } else if (user.status === "clocked-out") {
        ctx.globalAlpha = 0.1; // very faded for clocked out users
      }
      
      // Draw avatar for all users (including clocked-out with very low opacity)
      if (useRegularDesk) {
        // For regular desks (desk.png), use normal positioning
        ctx.drawImage(
          spriteSheet,
          frameToDraw * config.frameWidth, 0, config.frameWidth, config.frameHeight,
          offsetX + avatarOffsetX, offsetY + avatarOffsetY, drawWidth, drawHeight
        );
      } else {
        // For other desks (deskop.png), flip avatar horizontally and shift more to the right
        avatarOffsetX = -6; // more pixels right (moved left)
        ctx.scale(-1, 1); // flip horizontally
        ctx.drawImage(
          spriteSheet,
          frameToDraw * config.frameWidth, 0, config.frameWidth, config.frameHeight,
          -(offsetX + avatarOffsetX + drawWidth), offsetY + avatarOffsetY, drawWidth, drawHeight
        );
        ctx.restore(); // Restore canvas state after flipped avatar
        ctx.save(); // Save state for name tag
      }
      ctx.globalAlpha = 1.0;
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      
      // Draw username with white text, dark blue fill, and white border
      const username = user.username;
      const textX = px + cellSize/2 - 10;
      const textY = py + cellSize - 50;
      
      // Measure text for background sizing
      const textMetrics = ctx.measureText(username);
      const textWidth = textMetrics.width;
      const textHeight = 14; // Smaller height for tighter fit
      const padding = 2; // Smaller padding for more centered look
      const borderWidth = 1; // Border width
      
      // Draw dark blue fill
      ctx.fillStyle = '#2d2e4b'; // Dark blue fill
      ctx.fillRect(
        textX - textWidth/2 - padding, 
        textY - textHeight - padding, 
        textWidth + padding * 2, 
        textHeight + padding * 2
      );
      
      // Draw white border
      ctx.strokeStyle = '#ffffff'; // White border
      ctx.lineWidth = borderWidth;
      ctx.strokeRect(
        textX - textWidth/2 - padding, 
        textY - textHeight - padding, 
        textWidth + padding * 2, 
        textHeight + padding * 2
      );
      
      // Draw white text
      ctx.fillStyle = '#ffffff'; // White text
      ctx.fillText(username, textX, textY);
      
      // Draw status circle in top right corner of name tag
      const circleRadius = 4;
      const circleX = textX + textWidth/2 + padding + circleRadius - 4; // Moved a little to the left
      const circleY = textY - textHeight - padding - circleRadius + 2; // Moved a little down
      
      // Set status circle color based on user status
      let statusColor;
      switch(user.status) {
        case 'clocked-in':
          statusColor = '#28a745'; // Green
          break;
        case 'break':
          statusColor = '#ffc107'; // Yellow
          break;
        case 'work-from-home':
          statusColor = '#17a2b8'; // Blue
          break;
        case 'job-site':
          statusColor = '#8B4513'; // Brown
          break;
        case 'clocked-out':
          statusColor = '#dc3545'; // Red
          break;
        default:
          statusColor = '#6c757d'; // Gray for unknown status
      }
      
      // Draw status circle
      ctx.beginPath();
      ctx.arc(circleX, circleY, circleRadius, 0, 2 * Math.PI);
      ctx.fillStyle = statusColor;
      ctx.fill();
      ctx.strokeStyle = '#2d2e4b';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
  });
  
  // Reset zoom and pan transformations
  resetZoomAndPan();
}

function animateSprite(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  const elapsed = timestamp - lastFrameTime;
  if (elapsed > frameDuration) {
    frameIndex = (frameIndex + 1) % totalFrames;
    lastFrameTime = timestamp;
  }
  drawOfficeWithUsers(boardUsers);
  requestAnimationFrame(animateSprite);
}

// Zoom and Pan Functions
function applyZoomAndPan() {
  ctx.save();
  ctx.translate(panX, panY);
  ctx.scale(zoomLevel, zoomLevel);
}

function resetZoomAndPan() {
  ctx.restore();
}

// Zoom controls
function zoomIn() {
  zoomLevel = Math.min(zoomLevel * 1.2, 3);
}

function zoomOut() {
  zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
}

function resetZoom() {
  zoomLevel = 1;
  panX = 0;
  panY = 0;
}

// Fullscreen function
function toggleFullscreen() {
  const canvas = document.getElementById('boardCanvas');
  
  // Check if fullscreen is supported
  if (!document.fullscreenEnabled && 
      !document.webkitFullscreenEnabled && 
      !document.mozFullScreenEnabled && 
      !document.msFullscreenEnabled) {
    alert('Fullscreen is not supported in this browser');
    return;
  }
  
  // Check if already in fullscreen
  if (!document.fullscreenElement && 
      !document.webkitFullscreenElement && 
      !document.mozFullScreenElement && 
      !document.msFullscreenElement) {
    // Enter fullscreen
    if (canvas.requestFullscreen) {
      canvas.requestFullscreen().catch(err => {
        console.log('Error attempting to enable fullscreen:', err);
        alert('Failed to enter fullscreen mode');
      });
    } else if (canvas.webkitRequestFullscreen) {
      canvas.webkitRequestFullscreen();
    } else if (canvas.mozRequestFullScreen) {
      canvas.mozRequestFullScreen();
    } else if (canvas.msRequestFullscreen) {
      canvas.msRequestFullscreen();
    }
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
}

// Event listeners for controls
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('refreshBtn').addEventListener('click', refreshData);
  document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
  document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
  document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
  document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
  
  // Mouse controls for panning
  const canvas = document.getElementById('boardCanvas');
  
  canvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      panX += deltaX;
      panY += deltaY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    }
  });
  
  canvas.addEventListener('mouseup', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });
  
  canvas.addEventListener('mouseleave', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });
  
  // Wheel zoom
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.5, Math.min(3, zoomLevel * zoomFactor));
    
    if (newZoom !== zoomLevel) {
      const scaleChange = newZoom / zoomLevel;
      panX = mouseX - (mouseX - panX) * scaleChange;
      panY = mouseY - (mouseY - panY) * scaleChange;
      zoomLevel = newZoom;
    }
  });
  
  canvas.style.cursor = 'grab';
});

  // Wait for both images to load before animating
  let imagesLoaded = 0;
  function checkLoaded() {
    imagesLoaded++;
    if (imagesLoaded === 2) {
      requestAnimationFrame(animateSprite);
    }
  }
  deskImg.onload = checkLoaded;
  spriteSheet.onload = checkLoaded;

  // Add click event listener to canvas for user info
  canvas.addEventListener('click', function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / zoomLevel;
    const y = (e.clientY - rect.top - panY) / zoomLevel;
    
    // Check if click is on a user
    const clickedUser = findUserAtPosition(x, y);
    if (clickedUser) {
      showUserInfo(clickedUser);
    }
  });

  function findUserAtPosition(x, y) {
    return boardUsers.find(user => {
      if (!user.desk) return false;
      
      let deskCoord = user.desk;
      if (typeof deskCoord === "string") {
        const [x, y] = deskCoord.split(',').map(Number);
        deskCoord = {x, y};
      }
      
      const px = deskCoord.x * cellSize;
      const py = deskCoord.y * cellSize;
      
      // Check if click is within the desk area (including avatar and name tag)
      return x >= px && x <= px + cellSize && y >= py && y <= py + cellSize;
    });
  }

  async function showUserInfo(user) {
    const modal = document.getElementById('userInfoModal');
    const title = document.getElementById('userInfoTitle');
    const details = document.getElementById('userInfoDetails');
    
    title.textContent = `${user.username}'s Information`;
    
    try {
      // Fetch user's detailed information including clock times
      console.log('Fetching user data from:', `${ApiUrlLink}/user/${user.username}`);
      const response = await fetch(`${ApiUrlLink}/user/${user.username}`);
      console.log('User response status:', response.status);
      console.log('User response ok:', response.ok);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const userData = await response.json();
      console.log('User data received:', userData);
      
      // Also fetch current hours data which might contain clock times
      let hoursData = null;
      try {
        console.log('Fetching hours data from:', `${ApiUrlLink}/current_hours`);
        const hoursResponse = await fetch(`${ApiUrlLink}/current_hours`);
        console.log('Hours response status:', hoursResponse.status);
        
        if (hoursResponse.ok) {
          const hoursResponseData = await hoursResponse.json();
          console.log('All hours data:', hoursResponseData);
          hoursData = hoursResponseData.find(u => u.username === user.username);
          console.log('Hours data for user:', user.username, hoursData);
        } else {
          console.log('Hours response not ok:', hoursResponse.status);
        }
      } catch (e) {
        console.log('Could not fetch hours data:', e);
      }
      
      console.log('User data from /user endpoint:', userData);
      console.log('Full hoursData object:', hoursData);
      console.log('Available fields in userData:', Object.keys(userData));
      console.log('Available fields in hoursData:', hoursData ? Object.keys(hoursData) : 'No hours data');
      console.log('Clock in time field found:', userData.clock_in_time || userData.clockInTime || userData.clock_in);
      console.log('Clock out time field found:', userData.clock_out_time || userData.clockOutTime || userData.clock_out);
      console.log('User status:', userData.status);
      
      // Calculate working time if clocked in
      let workingTime = 'N/A';
      let clockInTime = 'N/A';
      let clockOutTime = 'N/A';
      
      const clockInTimeField = userData.clock_in_time || userData.clockInTime || userData.clock_in || 
                              (hoursData && hoursData.clock_in_time) || (hoursData && hoursData.clockInTime);
      const clockOutTimeField = userData.clock_out_time || userData.clockOutTime || userData.clock_out || 
                               (hoursData && hoursData.clock_out_time) || (hoursData && hoursData.clockOutTime);
      
      if (clockInTimeField) {
        try {
          console.log('Parsing clock in time:', clockInTimeField);
          const clockIn = new Date(clockInTimeField);
          console.log('Parsed clock in Date object:', clockIn);
          console.log('Clock in timestamp:', clockIn.getTime());
          console.log('Is NaN:', isNaN(clockIn.getTime()));
          
          if (!isNaN(clockIn.getTime())) {
            clockInTime = clockIn.toLocaleTimeString();
            console.log('Successfully parsed clock in time:', clockInTime);
            
            if (userData.status === 'clocked-out' && clockOutTimeField) {
              try {
                console.log('Parsing clock out time:', clockOutTimeField);
                const clockOut = new Date(clockOutTimeField);
                console.log('Parsed clock out Date object:', clockOut);
                console.log('Clock out timestamp:', clockOut.getTime());
                console.log('Is NaN:', isNaN(clockOut.getTime()));
                
                if (!isNaN(clockOut.getTime())) {
                  clockOutTime = clockOut.toLocaleTimeString();
                  const duration = clockOut - clockIn;
                  workingTime = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                               Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
                  console.log('Successfully calculated working time for clocked-out user:', workingTime);
                }
              } catch (e) {
                console.log('Error parsing clock out time:', e);
              }
            } else if (userData.status !== 'clocked-out') {
              const now = new Date();
              const duration = now - clockIn;
              workingTime = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                           Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
              console.log('Successfully calculated working time for active user:', workingTime);
            }
          } else {
            console.log('Invalid clock in time - NaN result');
          }
        } catch (e) {
          console.log('Error parsing clock in time:', e);
        }
      } else {
        console.log('No clock in time field found');
      }
      
      // Calculate break times
      let breakStartTime = 'N/A';
      let breakEndTime = 'N/A';
      let breakDuration = 'N/A';

      const breakStartTimeField = userData.break_start_time || (hoursData && hoursData.break_start_time);
      const breakEndTimeField = userData.break_end_time || (hoursData && hoursData.break_end_time);

      if (breakStartTimeField) {
        try {
          const breakStart = new Date(breakStartTimeField);
          if (!isNaN(breakStart.getTime())) {
            breakStartTime = breakStart.toLocaleTimeString();
            
            // If user is currently on break, calculate current break duration
            if (userData.status === 'break') {
              const now = new Date();
              const duration = now - breakStart;
              breakDuration = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                             Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
            } else if (breakEndTimeField) {
              // User finished break, calculate break duration from start to end
              try {
                const breakEnd = new Date(breakEndTimeField);
                if (!isNaN(breakEnd.getTime())) {
                  const duration = breakEnd - breakStart;
                  breakDuration = Math.floor(duration / (1000 * 60 * 60)) + 'h ' + 
                                 Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
                  breakEndTime = breakEnd.toLocaleTimeString();
                }
              } catch (e) {
                console.log('Error calculating break end time:', e);
              }
            }
          }
        } catch (e) {
          console.log('Error parsing break start time:', e);
        }
      }
      
      // Handle desk coordinates properly
      let deskDisplay = 'N/A';
      if (user.desk) {
        if (typeof user.desk === 'string') {
          deskDisplay = user.desk;
        } else if (user.desk.x !== undefined && user.desk.y !== undefined) {
          deskDisplay = `${user.desk.x}, ${user.desk.y}`;
        }
      }

      // Get work and break hours from the backend data
      const workHours = hoursData ? hoursData.work_hours : (userData.work_hours || 0);
      const breakHours = hoursData ? hoursData.break_hours : (userData.break_hours || 0);
      
      // Format hours for display
      const formatHours = (hours) => {
        if (hours === 0) return '0h 0m';
        const wholeHours = Math.floor(hours);
        const minutes = Math.round((hours - wholeHours) * 60);
        return `${wholeHours}h ${minutes}m`;
      };

      // Get job site location if available
      const jobSiteLocation = userData.job_site_location || 'N/A';
      
      // Create Google Maps link for job site location
      const createMapLink = (location) => {
        if (location && location !== 'N/A') {
          const encodedLocation = encodeURIComponent(location);
          return `https://www.google.com/maps/search/?api=1&query=${encodedLocation}`;
        }
        return null;
      };
      
      const mapLink = createMapLink(jobSiteLocation);
      
      details.innerHTML = `
        <div class="user-info-item">
          <span class="user-info-label">Email:</span>
          <span class="user-info-value">${userData.email || 'N/A'}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Status:</span>
          <span class="user-info-value">${userData.status || 'N/A'}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Desk:</span>
          <span class="user-info-value">${deskDisplay}</span>
        </div>
        ${userData.status === 'job-site' ? `
        <div class="user-info-item">
          <span class="user-info-label">Job Site Location:</span>
          <span class="user-info-value">
            ${mapLink ? 
              `<a href="${mapLink}" target="_blank" style="color: #007bff; text-decoration: underline; cursor: pointer;">${jobSiteLocation} üìç</a>` : 
              jobSiteLocation
            }
          </span>
        </div>
        ` : ''}
        <div class="user-info-item">
          <span class="user-info-label">Clock In Time:</span>
          <span class="user-info-value">${clockInTime}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Total Work Hours:</span>
          <span class="user-info-value">${formatHours(workHours)}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Total Break Hours:</span>
          <span class="user-info-value">${formatHours(breakHours)}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Current Session:</span>
          <span class="user-info-value">${workingTime}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Clock Out Time:</span>
          <span class="user-info-value">${clockOutTime}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Break Start Time:</span>
          <span class="user-info-value">${breakStartTime}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Break End Time:</span>
          <span class="user-info-value">${breakEndTime}</span>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Current Break:</span>
          <span class="user-info-value">${breakDuration}</span>
        </div>
      `;
    } catch (error) {
      console.error('Error in showUserInfo:', error);
      details.innerHTML = `<p>Error loading user information: ${error.message}</p>`;
    }
    
    modal.style.display = 'flex';
  }

  // Close user info modal
  document.getElementById('closeUserInfo').onclick = function() {
    document.getElementById('userInfoModal').style.display = 'none';
  };
  
  // Close modal when clicking outside
  document.getElementById('userInfoModal').onclick = function(e) {
    if (e.target === this) {
      this.style.display = 'none';
    }
  };

  // Basic canvas controls
  document.getElementById('refreshBtn').onclick = function() {
    location.reload();
  };

  document.getElementById('zoomInBtn').onclick = function() {
    // TODO: Implement zoom in functionality
    console.log('Zoom in clicked');
  };

  document.getElementById('zoomOutBtn').onclick = function() {
    // TODO: Implement zoom out functionality
    console.log('Zoom out clicked');
  };

  document.getElementById('resetZoomBtn').onclick = function() {
    // TODO: Implement reset zoom functionality
    console.log('Reset zoom clicked');
  };

  document.getElementById('fullscreenBtn').onclick = function() {
    const canvas = document.getElementById('boardCanvas');
    if (canvas.requestFullscreen) {
      canvas.requestFullscreen();
    } else if (canvas.webkitRequestFullscreen) {
      canvas.webkitRequestFullscreen();
    } else if (canvas.mozRequestFullScreen) {
      canvas.mozRequestFullScreen();
    } else if (canvas.msRequestFullscreen) {
      canvas.msRequestFullscreen();
    }
  };
}); // Close the first DOMContentLoaded event listener
  </script>
</body>
</html>
