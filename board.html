<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Office Board</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css?family=Quicksand:400,500,700&display=swap" rel="stylesheet">
  <script src="config.js" defer></script>
  <script defer>
    document.addEventListener("DOMContentLoaded", () => {
      const base = document.createElement('base');
      base.href = location.hostname === 'localhost' ? '/' : 'https://joshthinh.github.io/Elen-Signin/';
      document.head.appendChild(base);
  
      // Ensure config.js is loaded before accessing API_URL / API_URL_DEPLOYED
      if (typeof API_URL === 'undefined' || typeof API_URL_DEPLOYED === 'undefined') {
        console.error('API_URL or API_URL_DEPLOYED is not defined. Check config.js loading.');
        return;
      }
  
      window.ApiUrlLink = location.hostname === 'localhost' ? API_URL : API_URL_DEPLOYED;
  
      // Continue rest of logic here if needed
    });
  </script>
  <style>
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      margin: 0;
      font-family: 'Crimson Text', serif;
      font-size: 16px;
      color: #777777;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      padding-top: 56px; /* Prevent content from being hidden under navbar */
    }
    .navbar {
      width: 100%;
      height: 60px;
      background: #2d2e4bf2;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1001;
      box-sizing: border-box;
      padding-right: 8px;
      transition: background 0.4s;
    }
    .navbar-hamburger {
      font-size: 2rem;
      cursor: pointer;
      padding: 0 24px;
      user-select: none;
    }
    .navbar-title {
      font-size: 1.3rem;
      font-weight: bold;
      margin-left: 12px;
    }
    .sidebar {
      position: fixed;
      top: 0;
      right: -220px;
      width: 220px;
      height: 100%;
      background: #2d2e4bf2;
      color: rgba(45, 46, 75, 0.95);
      display: flex;
      flex-direction: column;
      padding-top: 56px;
      transition: right 0.3s;
      z-index: 1002;
    }
    .sidebar.open {
      right: 0;
    }
    .sidebar a {
      color: #DDDDDD;
      padding: 18px 24px;
      text-decoration: none;
      font-size: 1.1rem;
      border-bottom: 1px solid #444;
      transition: background 0.2s;
    }
    .sidebar a:hover {
      background: rgba(45, 46, 75, 0.8);
      color: #fff;
      ;
    }
    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.3);
      z-index: 1000;
    }
    .sidebar-overlay.open {
      display: block;
    }
    .board-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    .board-title {
      margin-bottom: 20px;
      color: #333;
      font-size: 2rem;
      font-weight: bold;
    }
    
    /* Board Header and Stats */
    .board-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 20px;
    }
    
    .board-stats {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: white;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      min-width: 100px;
    }
    
    .stat-label {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 4px;
    }
    
    .stat-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #2d2e4b;
    }
    
    /* Canvas Container */
    .canvas-container {
      position: relative;
      overflow: hidden;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
    }
    
    /* Board Controls */
    .board-controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .control-btn {
      background: #2d2e4b;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    .control-btn:hover {
      background: #1a1b2e;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .board-header {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .board-stats {
        justify-content: center;
        width: 100%;
      }
      
      .stat-item {
        min-width: 80px;
        padding: 8px 12px;
      }
      
      .board-controls {
        gap: 8px;
      }
      
      .control-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <nav class="navbar">
    <div class="header">
      <h1>Office Board</h1>
    </div>
    <div class="navbar-title"></div>
    <div class="navbar-hamburger" id="navbarHamburger">&#9776;</div>
  </nav>
  <div class="sidebar" id="sidebar">
    <a href="#" id="dashboardLink">Dashboard</a>
    <!--<a href="#" id="boardLink">Board</a>-->
    <a href="#" id="settingsLink">Settings</a>
    <a href="#" id="submitLink">Submit Email</a>
    <a href="#" id="viewEmailLink">View Email</a>
    <a href="#" id="hourLink">Hours</a>
    <a href="#" id="editUsersLink">Edit Users</a>
    <a href="#" id="signOutLink">Sign Out</a>
  </div>
  <div class="sidebar-overlay" id="sidebarOverlay"></div>
  
  <div class="board-container">
    <div class="board-header">
      <h1 class="board-title">Office Presence Board</h1>
      <div class="board-stats">
        <div class="stat-item">
          <span class="stat-label">Total Active:</span>
          <span class="stat-value" id="totalActive">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Clocked In:</span>
          <span class="stat-value" id="clockedInCount">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">On Break:</span>
          <span class="stat-value" id="breakCount">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Last Updated:</span>
          <span class="stat-value" id="lastUpdated">--</span>
        </div>
      </div>
    </div>
    
    <div class="canvas-container">
      <canvas id="boardCanvas" width="1100" height="700" style="display:block; margin: 40px auto; background: #f8f9fa; border: 3px solid #333333; border-radius: 16px; box-shadow: 0 4px 24px rgba(0,0,0,0.08);"></canvas>
    </div>
    
    <div class="board-controls">
      <button id="refreshBtn" class="control-btn">üîÑ Refresh</button>
      <button id="zoomInBtn" class="control-btn">üîç+</button>
      <button id="zoomOutBtn" class="control-btn">üîç-</button>
      <button id="resetZoomBtn" class="control-btn">üîç Reset</button>
      <button id="fullscreenBtn" class="control-btn">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <script defer>
// --- Navbar/Sidebar logic (dashboard style) ---
document.getElementById('navbarHamburger').onclick = function() {
  document.getElementById('sidebar').classList.add('open');
  document.getElementById('sidebarOverlay').classList.add('open');
};
document.getElementById('sidebarOverlay').onclick = function() {
  document.getElementById('sidebar').classList.remove('open');
  document.getElementById('sidebarOverlay').classList.remove('open');
};
document.getElementById('signOutLink').onclick = function(e) {
  e.preventDefault();
  localStorage.removeItem("user");
          window.location.href = "index.html";
};
document.addEventListener("DOMContentLoaded", () => {
  function getQueryParam(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
  }
  const username = getQueryParam('username');
  // Update all sidebar links to include username
  if (username) {
    document.getElementById('dashboardLink').href = `dashboard.html?username=${encodeURIComponent(username)}`;
    // document.getElementById('boardLink').href = `board.html?username=${encodeURIComponent(username)}`;
    document.getElementById('settingsLink').href = `settings.html?username=${encodeURIComponent(username)}`;
    document.getElementById('viewEmailLink').href = `view_email.html?username=${encodeURIComponent(username)}`;
    document.getElementById('submitLink').href = `submit_email.html?username=${encodeURIComponent(username)}`;
    document.getElementById('hourLink').href = `hours.html?username=${encodeURIComponent(username)}`;
    document.getElementById('editUsersLink').href = `users.html?username=${encodeURIComponent(username)}`;
    // Fetch user info to determine admin status
    fetch(`${ApiUrlLink}/user/${username}`)
      .then(res => res.json())
      .then(user => {
        if (user && user.role === 'admin') {
          document.getElementById('hourLink').style.display = 'block';
        } else {
          document.getElementById('hourLink').style.display = 'none';
        }
        // Edit Users link is now visible to everyone
      });
  }
});
// --- End Navbar/Sidebar logic ---
document.addEventListener('DOMContentLoaded', () => {
const canvas = document.getElementById('boardCanvas');
const ctx = canvas.getContext('2d');

let frameIndex = 0;
let lastFrameTime = 0;

// Desk and character sprite config

const deskImg = new Image();
deskImg.src = `${document.baseURI}Static/Images/Desks/desk.png`;
const deskOpImg = new Image();
deskOpImg.src = `${document.baseURI}Static/Images/Desks/deskop.png`;



const spriteSheet = new Image();
spriteSheet.src = `${document.baseURI}Static/Images/Characters/Boy_idle.png`;

const frameWidth = 48;
const frameHeight = 48;
const totalFrames = 4;
const frameDuration = 200; // ms per frame

// --- Office Layout Config ---
const gridCols = 22; // number of columns in your grid (positions 0-21)
const gridRows = 8; // number of rows in your grid (reduced to match your layout)
const cellSize = 64; // pixels per grid cell
canvas.width = gridCols * cellSize;
canvas.height = gridRows * cellSize;

  // Desk positions from the provided text grid (x = column, y = row, 0-indexed)
  const deskPositions = [
    // Row 0: xoxox
    {x:1, y:0}, {x:3, y:0},
    // Row 1: oxxx
    {x:0, y:1},
    // Row 2: oxxoxxxo
    {x:0, y:2}, {x:3, y:2}, {x:8, y:2},
    // Row 3: xxxxxxxxxxoxxoxxo
    {x:10, y:4}, {x:11, y:4}, {x:13, y:4}, {x:14, y:4}, {x:16, y:4}, {x:17, y:4},
    // Row 4: oxxxx
    {x:0, y:5},
    // Row 5: oxxooxooxooxooxooxo
    {x:0, y:6}, {x:2, y:6}, {x:3, y:6}, {x:6, y:6}, {x:7, y:6}, {x:10, y:6}, {x:11, y:6}, {x:14, y:6}, {x:15, y:6}, {x:18, y:6}, {x:19, y:6}, {x:21, y:6},
    // Row 6: xxxooxooxooxooxooxo
    {x:2, y:7}, {x:3, y:7}, {x:6, y:7}, {x:7, y:7}, {x:10, y:7}, {x:11, y:7}, {x:14, y:7}, {x:15, y:7}, {x:18, y:7}, {x:19, y:7}, {x:21, y:7},
  ];
// --- Drawing Logic ---
// Global users array for animation
let boardUsers = [];

// Global variables for zoom and pan
let zoomLevel = 1;
let panX = 0;
let panY = 0;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;

// Function to update statistics
function updateStats(users) {
  const activeUsers = users.filter(user => 
    user.desk && (user.status === "clocked-in" || user.status === "break")
  );
  const clockedInUsers = users.filter(user => 
    user.desk && user.status === "clocked-in"
  );
  const breakUsers = users.filter(user => 
    user.desk && user.status === "break"
  );
  
  document.getElementById('totalActive').textContent = activeUsers.length;
  document.getElementById('clockedInCount').textContent = clockedInUsers.length;
  document.getElementById('breakCount').textContent = breakUsers.length;
  document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
}

// Function to refresh data
function refreshData() {
  fetch(`${ApiUrlLink}/users`)
    .then(res => res.json())
    .then(data => {
      boardUsers = data.users;
      updateStats(boardUsers);
      requestAnimationFrame(animateSprite);
    })
    .catch(error => {
      console.error('Error fetching users:', error);
    });
}

// Fetch users and update boardUsers, then start animation
refreshData();

// Auto-refresh every 30 seconds
setInterval(refreshData, 30000);

// Avatar animation configs
const avatarConfigs = {
  "City_men_idle.png": {
    frameWidth: 128,
    frameHeight: 128,
    totalFrames: 6,
    frameDuration: 250, // slower
    frameSequence: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] // loop
  },
  "Boy_idle.png": {
    frameWidth: 48,
    frameHeight: 48,
    totalFrames: 4,
    frameDuration: 200
  }
};
const AVATAR_BOX_SIZE = 64;

// Avatar sprite cache
const avatarSpriteSheets = {};

function getAvatarSpriteSheet(file) {
  if (!avatarSpriteSheets[file]) {
    const img = new window.Image();
    img.src = `${document.baseURI}Static/Images/Characters/${file}`;
    avatarSpriteSheets[file] = img;
  }
  return avatarSpriteSheets[file];
}

// Per-user animation state
const userAnimStates = {};

// Load background carpet image
const carpetImg = new window.Image();
carpetImg.src = `${document.baseURI}Static/Images/Background/carpet.png`;

function drawOfficeWithUsers(users) {
  // Apply zoom and pan transformations
  applyZoomAndPan();
  
  // Draw carpet background
  if (carpetImg.complete) {
    const pattern = ctx.createPattern(carpetImg, 'repeat');
    ctx.save();
    ctx.setTransform(0.5, 0, 0, 0.5, 0, 0); // Scale down to 50%
    ctx.fillStyle = pattern;
    ctx.fillRect(0, 0, canvas.width * 2, canvas.height * 2);
    ctx.restore();
  } else {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  // Draw grid (optional, for visual reference)
  ctx.save();
  ctx.strokeStyle = '#999999';
  for (let r = 0; r <= gridRows; r++) {
    ctx.beginPath();
    ctx.moveTo(0, r * cellSize);
    ctx.lineTo(canvas.width, r * cellSize);
    ctx.stroke();
  }
  for (let c = 0; c <= gridCols; c++) {
    ctx.beginPath();
    ctx.moveTo(c * cellSize, 0);
    ctx.lineTo(c * cellSize, canvas.height);
    ctx.stroke();
  }
  ctx.restore();

  // Add overlay to fade background (before desks)
  ctx.save();
  ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // White overlay with 40% opacity
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  // Draw desks
  deskPositions.forEach(desk => {
    const px = desk.x * cellSize;
    const py = desk.y * cellSize;
    ctx.save();
    
    // Use desk.png for specific x-coordinates (2, 6, 10, 14, 18, 21)
    const useRegularDesk = [2, 6, 10, 14, 18, 21].includes(desk.x);
    const deskImage = useRegularDesk ? deskImg : deskOpImg;
    
    ctx.drawImage(
      deskImage,
      px, py,
      cellSize, cellSize
    );
    ctx.restore();
  });

  // Draw users at their desks
  users.forEach(user => {
    if (!user.avatar) return;
    if (user.desk && (user.status === "clocked-in" || user.status === "break")) {
      let deskCoord = user.desk;
      if (typeof deskCoord === "string") {
        const [x, y] = deskCoord.split(',').map(Number);
        deskCoord = {x, y};
      }
      const px = deskCoord.x * cellSize;
      const py = deskCoord.y * cellSize;
      const config = avatarConfigs[user.avatar] || avatarConfigs[Object.keys(avatarConfigs)[0]];
      const sequence = config.frameSequence || [...Array(config.totalFrames).keys()];
      const seqLen = sequence.length;
      const spriteSheet = getAvatarSpriteSheet(user.avatar);
      // Per-user animation state
      if (!userAnimStates[user.username]) {
        userAnimStates[user.username] = { frameIndex: 0, lastFrameTime: 0, seqIndex: 0 };
      }
      const state = userAnimStates[user.username];
      const now = performance.now();
      if (!state.lastFrameTime) state.lastFrameTime = now;
      const elapsed = now - state.lastFrameTime;
      if (elapsed > config.frameDuration) {
        state.seqIndex = (state.seqIndex + 1) % seqLen;
        state.lastFrameTime = now;
      }
      const frameToDraw = sequence[state.seqIndex];
      // Scale and center in 64x64 box
      const scale = Math.min(
        AVATAR_BOX_SIZE / config.frameWidth,
        AVATAR_BOX_SIZE / config.frameHeight
      );
      const drawWidth = config.frameWidth * scale;
      const drawHeight = config.frameHeight * scale;
      const offsetX = px + (cellSize - AVATAR_BOX_SIZE) / 2 + (AVATAR_BOX_SIZE - drawWidth) / 2;
      const offsetY = py + (cellSize - AVATAR_BOX_SIZE) / 2 + (AVATAR_BOX_SIZE - drawHeight) / 2;
      // Check if user is at a desk that uses desk.png (regular desk)
      const useRegularDesk = [2, 6, 10, 14, 18, 21].includes(deskCoord.x);
      
      // Adjust avatar positioning and direction based on desk type
      let avatarOffsetX = 6; // default pixels left (moved back to the right)
      let avatarOffsetY = -16; // pixels up (moved higher)
      
      ctx.save();
      if (user.status === "break") {
        ctx.globalAlpha = 0.3; // faded
      }
      
      if (useRegularDesk) {
        // For regular desks (desk.png), use normal positioning
        ctx.drawImage(
          spriteSheet,
          frameToDraw * config.frameWidth, 0, config.frameWidth, config.frameHeight,
          offsetX + avatarOffsetX, offsetY + avatarOffsetY, drawWidth, drawHeight
        );
      } else {
        // For other desks (deskop.png), flip avatar horizontally and shift more to the right
        avatarOffsetX = -6; // more pixels right (moved left)
        ctx.scale(-1, 1); // flip horizontally
        ctx.drawImage(
          spriteSheet,
          frameToDraw * config.frameWidth, 0, config.frameWidth, config.frameHeight,
          -(offsetX + avatarOffsetX + drawWidth), offsetY + avatarOffsetY, drawWidth, drawHeight
        );
        ctx.restore(); // Restore canvas state after flipped avatar
        ctx.save(); // Save state for name tag
      }
      ctx.globalAlpha = 1.0;
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      
      // Draw username with blue text, light grey fill, and blue border
      const username = user.username;
      const textX = px + cellSize/2 - 10;
      const textY = py + cellSize - 50;
      
      // Measure text for background sizing
      const textMetrics = ctx.measureText(username);
      const textWidth = textMetrics.width;
      const textHeight = 14; // Smaller height for tighter fit
      const padding = 2; // Smaller padding for more centered look
      const borderWidth = 1; // Border width
      
      // Draw light grey fill
      ctx.fillStyle = '#e0e0e0'; // Light grey fill
      ctx.fillRect(
        textX - textWidth/2 - padding, 
        textY - textHeight - padding, 
        textWidth + padding * 2, 
        textHeight + padding * 2
      );
      
      // Draw blue border
      ctx.strokeStyle = '#2d2e4b'; // Theme blue color for border
      ctx.lineWidth = borderWidth;
      ctx.strokeRect(
        textX - textWidth/2 - padding, 
        textY - textHeight - padding, 
        textWidth + padding * 2, 
        textHeight + padding * 2
      );
      
      // Draw blue text matching theme
      ctx.fillStyle = '#2d2e4b'; // Theme blue color
      ctx.fillText(username, textX, textY);
      
      ctx.restore();
    }
  });
  
  // Reset zoom and pan transformations
  resetZoomAndPan();
}

function animateSprite(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  const elapsed = timestamp - lastFrameTime;
  if (elapsed > frameDuration) {
    frameIndex = (frameIndex + 1) % totalFrames;
    lastFrameTime = timestamp;
  }
  drawOfficeWithUsers(boardUsers);
  requestAnimationFrame(animateSprite);
}

// Zoom and Pan Functions
function applyZoomAndPan() {
  ctx.save();
  ctx.translate(panX, panY);
  ctx.scale(zoomLevel, zoomLevel);
}

function resetZoomAndPan() {
  ctx.restore();
}

// Zoom controls
function zoomIn() {
  zoomLevel = Math.min(zoomLevel * 1.2, 3);
}

function zoomOut() {
  zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
}

function resetZoom() {
  zoomLevel = 1;
  panX = 0;
  panY = 0;
}

// Fullscreen function
function toggleFullscreen() {
  const canvas = document.getElementById('boardCanvas');
  if (!document.fullscreenElement) {
    canvas.requestFullscreen().catch(err => {
      console.log('Error attempting to enable fullscreen:', err);
    });
  } else {
    document.exitFullscreen();
  }
}

// Event listeners for controls
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('refreshBtn').addEventListener('click', refreshData);
  document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
  document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
  document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
  document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
  
  // Mouse controls for panning
  const canvas = document.getElementById('boardCanvas');
  
  canvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      panX += deltaX;
      panY += deltaY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    }
  });
  
  canvas.addEventListener('mouseup', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });
  
  canvas.addEventListener('mouseleave', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });
  
  // Wheel zoom
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.5, Math.min(3, zoomLevel * zoomFactor));
    
    if (newZoom !== zoomLevel) {
      const scaleChange = newZoom / zoomLevel;
      panX = mouseX - (mouseX - panX) * scaleChange;
      panY = mouseY - (mouseY - panY) * scaleChange;
      zoomLevel = newZoom;
    }
  });
  
  canvas.style.cursor = 'grab';
});

// Wait for both images to load before animating
let imagesLoaded = 0;
function checkLoaded() {
  imagesLoaded++;
  if (imagesLoaded === 2) {
    requestAnimationFrame(animateSprite);
  }
}
deskImg.onload = checkLoaded;
spriteSheet.onload = checkLoaded;
}); // Close the first DOMContentLoaded event listener
  </script>
</body>
</html>
